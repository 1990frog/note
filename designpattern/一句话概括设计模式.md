<!-- TOC -->

- [创建型模式](#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F)
- [结构型模式](#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F)
- [行为型模式](#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F)
- [设计原则](#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99)
- [设计模式概况](#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E5%86%B5)

<!-- /TOC -->

# 创建型模式
1. 工厂方法模式
2. 抽象工厂模式
3. [单例模式](Singleton.md)
4. [建造者模式](Builder.md)
5. 原型模式
# 结构型模式
1. [适配器模式Adapter](Adapter.md)
2. [装饰器模式](Decorator.md)
3. [代理模式](Proxy.md)
4. 外观模式
5. 桥接模式
6. 组合模式
7. [享元模式](Flyweight.md)
# 行为型模式
1. 策略模式
2. 模板方法模式
3. 观察者模式
4. 迭代子模式
5. [责任链模式](Chain.md)
6. 命令模式
7. 备忘录模式
8. 状态模式
9. 访问者模式
10. 中介者模式
11. 解释器模式
# 设计原则
1. 开闭原则：对扩展开放，对修改关闭。
2. 里氏代换原则：任何基类可以出现的地方，子类一定可以出现。
3. 依赖倒置原则：针对接口编程，依赖抽象而不依赖具体。
4. 接口隔离原则：拆分大接口，使用多个隔离接口，降低类间耦合。
5. 迪米特法则：最少知道原则，实体间尽量少的发生相互作用
6. 合成复用原则：尽量使用合成/聚合的方式，而不是继承。
# 设计模式概况
1. 工厂方法模式：创建同一接口的封装对象。
2. 单例模式：类只实例化一次
3. 建造者模式：用来创建复合对象，隐藏实现细节。
4. 原型模式：对象复制，减少对象创建。
5. 适配器模式：类、对象、接口适配器，将接口转换成另一个目标接口，消除不兼容问题。
6. 装饰模式：给对象添加动态的添加功能。
7. 代理模式：用另一个类来代替原对象执行操作。
8. 外观模式：将多个类放到一个类中，降低类间耦合度。
9. 桥接模式：事物内部抽象类具体实现不同，相同方法产生不同结果，分离抽象和实体。
10. 组合模式：部分整体的结构，类似树形结构
11. 享元模式：对象共享池
12. 策略模式：相同接口，不同实现类，同一方法结果不同，实现策略不同。
13. 模板方法模式：父类执行子类功能，但由子类实现。
14. 观察者模式：子类的动作，观察者能即使发现做出反应。
15. 迭代子模式：顺序遍历对象。
16. 责任链模式：每个类持有下个对象的引用，形成链条。
17. 命令模式：调用者通过中间类让接受者执行指令。
18. 备忘录模式：备份模式，记录自生参数，需要的时候恢复。
19. 状态模式：改变状态参数，相同方法不同实现
20. 访问者模式：通过接收访问者类，让访问者类改变主类的行为。
21. 中介者模式：通过中介者类管理另外几个类的关系。
22. 解释器模式：解释一种模式，比如正则表达式的解释器。

