<!-- TOC -->

- [何为代理](#%E4%BD%95%E4%B8%BA%E4%BB%A3%E7%90%86)
- [实现](#%E5%AE%9E%E7%8E%B0)
- [静态代理的缺陷](#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E7%BC%BA%E9%99%B7)
- [静态代理的优劣](#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E4%BC%98%E5%8A%A3)

<!-- /TOC -->

# 何为代理
人-->不够强
高达-->强
人进入高达

# 实现
在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。
也就是说：
代理对象 = 增强代码 + 目标对象（原对象）

# 静态代理的缺陷
程序员要手动为每一个目标类编写对应的代理类。如果当前系统已经有成百上千个类，工作量太大了。所以，现在我们的努力方向是：如何少写或者不写代理类，却能完成代理功能？

# 静态代理的优劣
优：
+ 职责清晰。可以看到，代理类的职责是很清楚的，对于上面的例子，我们可以很容易了解到代理类（黄牛）他可以做什么，因为代码已经明明白白的写清楚了。
+ 扩展性好。如果要多增加一个代理类，上述例子可以增加一个代理类（如网上购票APP），也可以实现购票的功能，实现方法如“黄牛”类一样。同时这样的扩展不会影响到原本的类。
+ 运行速度快。对于静态代理而言，在程序运行之前，代理类和被代理类的.class文件就已经存在了，因为安排的明明白白，所以运行起来的时候会比动态代理快。
劣：
+ 可维护性低。由于代理类和被代理类都实现了同一个接口，如果接口发生了更改，那么被代理类和所有的代理类都要进行修改，比如接口新增一个方法，那么所有的代理类和被代理类都要重写这个方法，这无疑增加了巨大的工作量。
+ 可重用性低。通过观察可以发现，代理类们的代码大体上其实是差不多的，但是由于个别的差异，导致我们不得不重新写一个新的代理类。
