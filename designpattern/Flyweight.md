[TOC]

# 享源模式（Flyweight）

## 一、简介
说到享元模式，第一个想到的应该就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，所以说享元模式是池技术的重要实现方式。  
比如我们每次创建字符串对象时，都需要创建一个新的字符串对象的话，内存开销会很大，所以如果第一次创建了字符串对象“adam“，下次再创建相同的字符串”adam“时，只是把它的引用指向”adam“，这样就实现了”adam“字符串再内存中的共享。  
举个最简单的例子，网络联机下棋的时候，一台服务器连接了多个客户端（玩家），如果我们每个棋子都要创建对象，那一盘棋可能就有上百个对象产生，玩家多点的话，因为内存空间有限，一台服务器就难以支持了，所以这里要使用享元模式，将棋子对象减少到几个实例。下面给出享元模式的定义。  
享元模式（Flyweight），运用共享技术有效地支持**大量细粒度**的对象。UML结构图如下：  

![flyweight_1](https://raw.githubusercontent.com/1990frog/imagebed/default/1602317296_20191227142545326_1268933794.png)

Flyweight是抽象享元角色。它是产品的抽象类，同时定义出对象的外部状态和内部状态（外部状态及内部状态相关内容见后方）的接口或实现。
ConcreteFlyweight是具体享元角色，是具体的产品类，实现抽象角色定义的业务；UnsharedConcreteFlyweight是不可共享的享元角色，一般不会出现在享元工厂中。
FlyweightFactory是享元工厂，它用于构造一个池容器，同时提供从池中获得对象的方法。  

## 二、内部状态和外部状态
上面享元模式的定义为我们提出了两个要求：细粒度和共享对象。我们知道分配太多的对象到应用程序中将有损程序的性能，同时还容易造成内存溢出，要避免这种情况，用到的就是共享技术，这里就需要提到内部状态和外部状态了。  

因为要求细粒度对象，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。  

内部状态：  
指对象共享出来的信息，存储在享元对象内部并且不会随环境的改变而改变。  
在享元对象内部并且不用随环境改变而改变的共享部分，成为享元对象的内部状态。  
外部状态： 指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。  
而随环境改变而改变的、不可以共享的状态就是外部状态。  
在实际使用中，能够共享的内部状态是有限的，因此享元对象一般都设计为较小的对象，它所包含的内部状态较少，这种对象也成为细粒度对象。  

在分析什么是细粒度对象之前，我们现了解一下享元对象的两个状态：内部状态和外部状态。

内部状态存储于ConcreteFlyweight对象之中，而外部对象则应该考虑由客户端对象存储或计算。当调用Flyweight对象的操作时，将该状态传递给它。

我们举一个最简单的例子，棋牌类游戏大家都有玩过吧，比如说说围棋和跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色略多一点，但也是不太变化的，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，我们落子嘛，落子颜色是定的，但位置是变化的，所以方位坐标就是棋子的外部状态。  

那么为什么这里要用享元模式呢？可以想象一下，上面提到的棋类游戏的例子，比如围棋，理论上有361个空位可以放棋子，常规情况下每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题。  

## 三、享元模式的应用
### 何时使用
+ 系统中有大量对象时
+ 这些对象消耗大量内存时
+ 这些对象的状态大部分可以外部化时
### 方法
+ 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储
### 优点
+ 大大减少了对象的创建，降低了程序内存的占用，提高效率
### 缺点
+ 提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变  
### 使用场景 
+ 系统中存在大量相似对象 
+ 需要缓冲池的场景 
+ 应用实例 
+ String常量池数据库连接池
### 注意事项
+ 注意划分内部状态和外部状态，否则可能会引起线程安全问题 这些类必须有一个工厂类加以控制

## 四、享元模式的实现
应用实例的话，其实上面的模板就已经是一个很好的例子了，类似于String常量池，没有的对象创建后存在池中，若池中存在该对象则直接从池中取出。  
为了更好的理解享元模式，这里再举一个实例，比如接了我一个小型的外包项目，是做一个产品展示网站，后来他的朋友们也希望做这样的网站，但要求都有些不同，我们当然不能直接复制粘贴再来一份，有任希望是新闻发布形式的，有人希望是博客形式的等等，而且因为经费原因不能每个网站租用一个空间。  
其实这里他们需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，这是造成服务器的大量资源浪费。如果整合到一个网站中，共享其相关的代码和数据，那么对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源；而对于代码，由于是一份实例，维护和扩展都更加容易。  
那么此时就可以用到享元模式了。UML图如下：  

![flyweight_2](https://raw.githubusercontent.com/1990frog/imagebed/default/1602317296_20191227142554017_1759786100.png)
