[TOC]

数组向尾部添加元素方便
链表向头部添加元素方便

# 概览
链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。

由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比数组快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而数组相应的时间复杂度分别是O(logn)和O(1)。

使用链表结构可以克服数组需要预先知道数据大小的缺点，但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

# 结构
数据粗存储在节点（Node）中
```c
struct node_st {
    void *datap;
    struct node_st *next, *prev;
};
```
## 单向链表
 
## 双向链表

## 循环链表

## 块状链表

---


# 栈 Stack
+ 栈也是一种线性结构
+ 相比数组，栈对应的操作是数组的子集
+ 只能从一端添加元素，也只能从一端取出元素
+ 这一端称为栈顶
+ 栈是一种后进先出的数据结构
+ Last In First Out（LIFO）
+ 在计算机的世界里，栈拥有着不可思议的作用

# 栈的应用
无处不在的Undo操作（撤销）
程序调用的系统栈

A2：A的第二行
编译器内部系统栈记录每次调用记录的点

# 栈的实现：5个操作
Stack<E>
+ void push(E)    #入栈
+ E pop()    #拿出栈顶元素，出栈
+ E peek()    #查看栈顶元素（top）
+ int getSize()    #元素数量
+ boolean isEmpty()    #栈是否为空

# 编写代码
从用户的角度看，支持这些操作就好（那就基于数组做吧）
具体底层实现，用户不关心
实现底层有多种实现方式

# 疑问：java 静态数组，动态数组

# 栈时间复杂度
```
int getSize(); O(1)
boolean isEmpty();O(1)
void push(E e);O(1)均摊
E pop();O(1)均摊
E peek();O(1)
```

# 栈的应用
+ undo操作：编辑器
+ 系统调用栈：操作系统
+ 括号匹配：编译器

美版的leetcode比较全

解：
如果是左侧的括号入栈，如果是能与栈顶对应的右括号，弹出左括号。最终栈size为0，说明当前字符串合法
栈顶元素反映了在嵌套的层次关系中，最近的需要匹配的元素

---


# 概览
链表像火车一样，一节接一节

# 优点
真正的动态，不需要处理固定容量的问题
# 缺点
丧失了随机访问的能力（数组开辟的空间在内存里是连续分布的，可以直接通过索引的偏移找到对应的数据o(1)）

# 为什么链表很重要
+ 链表：真正的动态数据结构
+ 最简单的动态数据结构
+ 更深入的理解引用（或者指针）
+ 更深入的理解递归
+ 辅助组成其他数据结构

# 数组和链表的对比
+ 数组最好用于索引有语义的情况：scores[2]，也不是索引有语义就适合使用数组，例如身份证号
+ 数组最大优点支持快速查询
+ 链表不适合索引有语义的情况
+ 链表最大优点动态

# 虚拟头结点
简化add边界
不支持随机访问

# 链表的时间复杂度分析
+ 增：o(n)，如果只对链表头进行操作：o(1)
+ 删：o(n)，如果只对链表头进行操作：o(1)
+ 查：o(n)，只查链表头的元素：o(1)

# 使用链表实现栈性能对比
# 使用链表实现队列性能对比



---

# 链表
链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。

使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（"links"）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。

链表可以在多种编程语言中实现。像Lisp和Scheme这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如C/C++和Java依靠易变工具来生成链表。
# 单链表（Singly linked list）
![800px-Singly-linked-list](https://raw.githubusercontent.com/1990frog/imagebed/default/1602316864_20200114101514180_595639613.png)
链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。

一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。

链表最基本的结构是在每个节点保存数据和到下一个节点的地址，在最后一个节点保存一个特殊的结束标记，另外在一个固定的位置保存指向第一个节点的指针，有的时候也会同时储存指向最后一个节点的指针。一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。但是也可以提前把一个节点的位置另外保存起来，然后直接访问。当然如果只是访问数据就没必要了，不如在链表上储存指向实际数据的指针。这样一般是为了访问链表中的下一个或者前一个（需要储存反向的指针，见下面的双向链表）节点。

相对于下面的双向链表，这种普通的，每个节点只有一个指针的链表也叫单向链表，或者单链表，通常用在每次都只会按顺序遍历这个链表的时候（例如图的邻接表，通常都是按固定顺序访问的）。

# 双向链表（Doubly linked list）
双向链表，又称为双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。
![800px-Doubly-linked-list](https://raw.githubusercontent.com/1990frog/imagebed/default/1602316864_20200114101550039_1485109242.png)

一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个连接：一个指向前一个节点，（当此“连接”为第一个“连接”时，指向空值或者空列表）；而另一个指向下一个节点，（当此“连接”为最后一个“连接”时，指向空值或者空列表）

在一些低级语言中, XOR-linking 提供一种在双向链表中通过用一个词来表示两个链接（前后），我们通常不提倡这种做法。

双向链表也叫双链表。双向链表中不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样可以从任何一个节点访问前一个节点，当然也可以访问后一个节点，以至整个链表。一般是在需要大批量的另外储存数据在链表中的位置的时候用。双向链表也可以配合下面的其他链表的扩展使用。

由于另外储存了指向链表内容的指针，并且可能会修改相邻的节点，有的时候第一个节点可能会被删除或者在之前添加一个新的节点。这时候就要修改指向首个节点的指针。有一种方便的可以消除这种特殊情况的方法是在最后一个节点之后、第一个节点之前储存一个永远不会被删除或者移动的虚拟节点，形成一个下面说的循环链表。这个虚拟节点之后的节点就是真正的第一个节点。这种情况通常可以用这个虚拟节点直接表示这个链表，对于把链表单独的存在数组里的情况，也可以直接用这个数组表示链表并用第0个或者第-1个（如果编译器支持）节点固定的表示这个虚拟节点。

# 乘法链表（Multiply linked list）
# 循环链表（Circular linked list）
在一个 循环链表中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。再来看另一种方法，循环链表可以被视为“无头无尾”。这种列表很利于节约数据存储缓存， 假定你在一个列表中有一个对象并且希望所有其他对象迭代在一个非特殊的排列下。

指向整个列表的指针可以被称作访问指针。

![800px-Circularly-linked-list](https://raw.githubusercontent.com/1990frog/imagebed/default/1602316865_20200114101727886_1726951595.png)
循环链表中第一个节点之前就是最后一个节点，反之亦然。循环链表的无边界使得在这样的链表上设计算法会比普通链表更加容易。对于新加入的节点应该是在第一个节点之前还是最后一个节点之后可以根据实际要求灵活处理，区别不大(详见下面实例代码)。当然，如果只会在最后插入数据（或者只会在之前），处理也是很容易的。

另外有一种模拟的循环链表，就是在访问到最后一个节点之后的时候，手工的跳转到第一个节点。访问到第一个节点之前的时候也一样。这样也可以实现循环链表的功能，在直接用循环链表比较麻烦或者可能会出现问题的时候可以用。


## 单向循环链表
## 双向循环链表
Josephu问题：据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人找到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从，Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。 如何用循环链表来求解Josephu问题？
# 块状链表

