

[TOC]

# 概览

数据结构的核心：增、删、改、查

数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。


测试结果非常依赖测试环境
比如，我们拿同样一段代码，分别用 Intel Core i9 处理器和 Intel Core i3 处理器来运行，不用说，i9 处理器要比 i3 处理器执行的速度快很多。还有，比如原本在这台机器上 a 代码执行的速度比 b 代码要快，等我们换到另一台机器上时，可能会有截然相反的结果。

测试结果受数据规模的影响很大
对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反映算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快！



# 大O表示法


大O描述的是算法的运行时间和输入数据之间的关系

那数据结构和算法有什么关系呢？为什么大部分书都把这两个东西放到一块儿来讲呢？这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。

比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。现在你对数据结构与算法是不是有了比较清晰的理解了呢？有了这些储备，下面我们来看看，究竟该怎么学数据结构与算法。

# 常见的复杂度

| 类型       | 意义                                                         | 举例                                             |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------ |
| $O(1)$     | 最低复杂度，常量值，也就是耗时或耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时或耗空间都不变 | hash取值</br>数组根据坐标取值</br>操作链表头元素 |
| $O(n)$     | 数据量增大几倍，耗时也就增大几倍                             | 遍历算法                                         |
| $O(n^2)$   | 对n个元素排序，需要扫描n×n次                                 | 冒泡排序</br>暴力算法                            |
| $O(logn)$  | 当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍 | 二分搜索树                                       |
| $O(nlogn)$ | 就是n乘以logn，当数据增大256倍时，耗时增大256×8=2048倍。这个复杂度高于线性低于平方。归并排序就是$O(nlogn)$的时间复杂度 | 归并排序                                         |

# 常见数据结构



# 均摊复杂度

# 复杂度震荡

数组resie()
出现问题的原因：removeLast时resize过于着急（Eager）
解决方案：Lazy
当size==capacity/4时，才将capacity减半