[TOC]

数据结构的核心：增、删、改、查


大O描述的是算法的运行时间和输入数据之间的关系

那数据结构和算法有什么关系呢？为什么大部分书都把这两个东西放到一块儿来讲呢？这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。

比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。现在你对数据结构与算法是不是有了比较清晰的理解了呢？有了这些储备，下面我们来看看，究竟该怎么学数据结构与算法。

# 常见的复杂度
| 类型       | 意义                                                                                                                   | 举例                                             |
| ---------- | ---------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ |
| $O(1)$     | 最低复杂度，常量值，也就是耗时或耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时或耗空间都不变                   | hash取值</br>数组根据坐标取值</br>操作链表头元素 |
| $O(n)$     | 数据量增大几倍，耗时也就增大几倍                                                                                       | 遍历算法                                         |
| $O(n^2)$   | 对n个元素排序，需要扫描n×n次                                                                                           | 冒泡排序</br>暴力算法                            |
| $O(logn)$  | 当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍                          | 二分搜索树                                       |
| $O(nlogn)$ | 就是n乘以logn，当数据增大256倍时，耗时增大256×8=2048倍。这个复杂度高于线性低于平方。归并排序就是$O(nlogn)$的时间复杂度 | 归并排序                                         |

# 常见数据结构



# 均摊复杂度

# 复杂度震荡
数组resie()
出现问题的原因：removeLast时resize过于着急（Eager）
解决方案：Lazy
当size==capacity/4时，才将capacity减半
