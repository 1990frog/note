<!-- TOC -->

- [特征](#%E7%89%B9%E5%BE%81)
- [概览](#%E6%A6%82%E8%A7%88)
- [优点](#%E4%BC%98%E7%82%B9)
- [缺点](#%E7%BC%BA%E7%82%B9)
- [为什么链表很重要](#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%93%BE%E8%A1%A8%E5%BE%88%E9%87%8D%E8%A6%81)
- [数组和链表的对比](#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AF%B9%E6%AF%94)
- [虚拟头结点（带头）](#%E8%99%9A%E6%8B%9F%E5%A4%B4%E7%BB%93%E7%82%B9%E5%B8%A6%E5%A4%B4)
- [链表的时间复杂度分析](#%E9%93%BE%E8%A1%A8%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)
- [分类](#%E5%88%86%E7%B1%BB)
- [单向链表](#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8)
- [双向链表](#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8)
- [带头链表](#%E5%B8%A6%E5%A4%B4%E9%93%BE%E8%A1%A8)
- [循环链表](#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8)
- [链表种类](#%E9%93%BE%E8%A1%A8%E7%A7%8D%E7%B1%BB)
    - [单链表（Singly linked list）](#%E5%8D%95%E9%93%BE%E8%A1%A8singly-linked-list)
    - [双向链表（Doubly linked list）](#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8doubly-linked-list)
- [更多和链表相关的话题](#%E6%9B%B4%E5%A4%9A%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AF%9D%E9%A2%98)
    - [简单翻译](#%E7%AE%80%E5%8D%95%E7%BF%BB%E8%AF%91)

<!-- /TOC -->

链表像火车一样，一节接一节

# 特征
+ 真动态（集合基于静态数组，每次扩容要重新分配资源）
+ 修改快O(1)强于数组
+ 查询速度O(logn)逊于数组

# 概览
链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。

使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（"links"）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。

# 优点
真正的动态，不需要处理固定容量的问题

# 缺点
丧失了随机访问的能力，数组开辟的空间在内存里是连续分布的，可以直接通过索引的偏移找到对应的数据o(1)

# 为什么链表很重要
+ 链表：真正的动态数据结构
+ 最简单的动态数据结构
+ 更深入的理解引用（或者指针）
+ 更深入的理解递归
+ 辅助组成其他数据结构

# 数组和链表的对比
+ 数组最好用于索引有语义的情况：scores[2]，也不是索引有语义就适合使用数组，例如身份证号
+ 数组最大优点支持快速查询
+ 链表不适合索引有语义的情况
+ 链表最大优点动态

# 虚拟头结点（带头）
+ 简化边界操作
+ 不支持随机访问

# 链表的时间复杂度分析
+ 增：o(n)，如果只对链表头进行操作：o(1)
+ 删：o(n)，如果只对链表头进行操作：o(1)
+ 查：o(n)，只查链表头的元素：o(1)


# 分类
+ 带头 or 不带头
+ 单向 or 双向
+ 循环 or 非循环

# 单向链表
单向链表（又名单链表、线性链表）是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过从头部开始，依序往下读取。 
```c
/* c2-2.h 线性表的单链表存储结构 */
typedef struct LNode
{
	ElemType data;
	struct LNode *next;
}LNode,*LinkList;
```
# 双向链表
双向链表，又称为双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接 __后继__ 和 __直接前驱__。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。 
```c
/* c2-4.h 线性表的双向链表存储结构 */
typedef struct DuLNode
{
	ElemType data;
	struct DuLNode *prior,*next;
}DuLNode,*DuLinkList;
```
# 带头链表
带头结点：在带头结点的链表中，head指针始终指向一个节点，这个节点不存储有效值，仅仅起到一个标识作用（有点像班主任带着学生）。不带头结点：在不带头结点的链表中，head指针始终指向第一个有效节点，这个节点存储有效数值。那么带头结点和不带头结点的链表有什么区别呢？查找方面：在查找操作上，它们没有太大区别，带头结点需要多进行一次查找。插入方面：对于非第0个位置的插入操作，区别不大，但不带头结点的链表在插入第0号位置之后需要重新改变head头指针的指向。

# 循环链表
循环链表是一种链式存储结构，它的最后一个结点指向头结点，形成一个环。因此，从循环链表中的任何一个结点出发都能找到任何其他结点。循环链表的操作和单链表的操作基本一致，差别仅仅在于算法中的循环条件有所不同。 
```c
/* c2-2.h 线性表的单链表存储结构 */
typedef struct LNode
{
	ElemType data;
	struct LNode *next;
}LNode,*LinkList;
```

[约瑟夫环](https://zh.wikipedia.org/zh-cn/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)





# 链表种类
## 单链表（Singly linked list）
一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。

链表最基本的结构是在每个节点保存数据和到下一个节点的地址，在最后一个节点保存一个特殊的结束标记，另外在一个固定的位置保存指向第一个节点的指针，有的时候也会同时储存指向最后一个节点的指针。

一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。但是也可以提前把一个节点的位置另外保存起来，然后直接访问。当然如果只是访问数据就没必要了，不如在链表上储存指向实际数据的指针。这样一般是为了访问链表中的下一个或者前一个（需要储存反向的指针，见下面的双向链表）节点。

相对于下面的双向链表，这种普通的，每个节点只有一个指针的链表也叫单向链表，或者单链表，通常用在每次都只会按顺序遍历这个链表的时候（例如图的邻接表，通常都是按固定顺序访问的）。

## 双向链表（Doubly linked list）
双向链表，又称为双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接 __后继__ 和 __直接前驱__ 。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。

一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个连接：一个指向前一个节点，（当此“连接”为第一个“连接”时，指向空值或者空列表）；而另一个指向下一个节点，（当此“连接”为最后一个“连接”时，指向空值或者空列表）

在一些低级语言中, XOR-linking 提供一种在双向链表中通过用一个词来表示两个链接（前后），我们通常不提倡这种做法。

双向链表也叫双链表。双向链表中不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样可以从任何一个节点访问前一个节点，当然也可以访问后一个节点，以至整个链表。一般是在需要大批量的另外储存数据在链表中的位置的时候用。双向链表也可以配合下面的其他链表的扩展使用。

由于另外储存了指向链表内容的指针，并且可能会修改相邻的节点，有的时候第一个节点可能会被删除或者在之前添加一个新的节点。这时候就要修改指向首个节点的指针。有一种方便的可以消除这种特殊情况的方法是在最后一个节点之后、第一个节点之前储存一个永远不会被删除或者移动的虚拟节点，形成一个下面说的循环链表。这个虚拟节点之后的节点就是真正的第一个节点。这种情况通常可以用这个虚拟节点直接表示这个链表，对于把链表单独的存在数组里的情况，也可以直接用这个数组表示链表并用第0个或者第-1个（如果编译器支持）节点固定的表示这个虚拟节点。





















# 更多和链表相关的话题
斯坦福文档：LinkedListProblems.pdf

## 简单翻译
链表属于极其经典的数据结构之一，大家在学习数据结构的时候，一定学习过链表这种数据结构。虽然在实际生产环境中手写链表的场景并不多，但是链表依然是非常有用的一种数据结构，在很多语言的底层有着不可替代的作用。

最最重要的是，链表是笔试面试或者各种计算机水平考察中的常客。为什么？

首先，因为链表拥有着极其简单的结构，但却能引申出相当复杂优美的算法思想。这是因为同二叉树一样，链表也拥有着天然的递归性质！每一个链表节点的next，链接的是一个更小的链表！这使得近乎所有对链表的操作，都可以使用递归的方式完成。只不过由于链表天然是线性的，非常方便迭代遍历，使得很多人忽视了链表的递归性质。我个人认为，同二叉树一样，对于所有的链表的问题，在学习阶段，都有必要使用递归和非递归两种方式完成。这个过程将大大加深对递归的理解。很多同学会问我很多和二叉树相关的递归问题，但这些问题其实在链表中也是同样成立的。究其根本，是从链表的学习开始，就对递归没有建立深刻的认识。

另一方面，操作链表将不可避免的操作指针（C++中的指针，其他语言中的引用）。对指针或者引用这个概念的熟练掌握，是使用任何编程语言都逃不过的概念。而链表本身，提供了一个结构简单，却又能充分理解实验这个概念的最佳场所。

怎么学习链表？大多数数据结构教材都会对链表进行充分的讲解，并且辅以相关的练习题。但是很多教材中和链表相关的练习稍显混乱，显得不成体系。斯坦福大学的计算机系整理了一份和链表相关的18个问题，充分编程实践这18个问题，基本就可以说把“链表”这个知识点打通关了。我个人建议，对于还处于基础学习阶段的同学，对下列问题中的大多数问题，都可以思考使用递归和非递归两种方式完成。

这18个问题如下：
1. Count 计算链表的节点个数
2. GetNth 获得链表第n个节点的值
3. CreateList 根据数组（或者标准输入）创建链表，DeleteList 释放一个链表的所有节点空间（C++）
4. Push 向链表头插入一个新节点；Pop 删除链表的第一个节点并返回。注意：我们可以将链表看做是一个队列，此时，向链表的头或者尾插入或者删除元素，就可以衍生出两个Push实现和两个Pop实现。大家也可以显示地将这四个方法命名为addFirst, addLast, removeFirst, removeLast（参考Java中的命名方式），并据此封装底层基于链表的栈，队列，双向队列等等线性数据结构：）
5. InsertNth 在链表的第n个位置插入一个新节点
6. SortedInsert 给定一个有序链表，将一个新节点插入到有序链表的正确位置
7. InsertSort 使用插入排序法为链表排序；提示：之前实现的SortedInsert有用了：）
8. Append 挂接两个链表
9. FrontBackSplit 将一个链表分割成大小相等的两个链表（对于原链表大小为奇数的情况，分割为大小只相差1的两个链表）
10. RemoveDuplicates 给定一个有序链表，其中含有重复节点，删除链表中的重复节点，使得每个不同值的节点只有一个
11. MoveNode 给定两个链表，Pop出第二个链表的元素，Push进第一个链表。注意：这里的Pop和Push可以根据实际场景使用4中的任意一组定义
12. AlternatingSplit 给定一个链表，将他分割成两个链表，其中奇数位置的节点在一个链表，偶数位置的节点在另一个链表；提示：之前实现的MoveNode有用了：）
13. ShuffleMerge 给定两个链表，将这两个链表合并成一个链表，其中一个链表的元素在奇数位，另一个链表的元素在偶数位；提示：之前实现的MoveNode有用了：）
14. SortedMerge 给定两个有序链表，将他们合并成为一个有序链表；提示：之前实现的MoveNode有用了：）
15. MergeSort 对链表进行归并排序。提示：实现了FrontBackSplit和SortedMerge，是不是觉得很简单：）当然，也可以尝试一下自底向上的归并排序（非递归的归并排序）。另外，对MergeSort的一个经典优化，是递归到达小数据量的时候，转而使用插入排序法。此时，我们自己写的InsertSort也有用了：）
16. SortedIntersect 给定两个有序链表，返回一个新链表，新链表中的元素是给定两个链表的公共元素。提示：以这个方法为基础，可以封装基于链表的集合类。大家也可以思考一下如何实现其他集合操作，如Union(合并)，Diff(差集)等等。
17. Reverse 反转一个链表
18. RecursiveReverse 使用递归的方式反转一个链表。提示：最后特意将递归方式翻转链表列出来，是因为这个问题实在是太经典了，充分体现了和链表相关算法的美丽：）
