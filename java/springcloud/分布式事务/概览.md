[TOC]

# 案例
对于网上购物的每一笔订单来说，电商平台一般都会有两个核心步骤：一是订单业务采取下订单操作，二是库存业务采取减库存操作
通常，这两个业务会运行在不同的机器上，甚至是运行在不同区域的机器上。针对同一笔订单，当且仅当订单操作和减库存操作一致时，才能保证交易的正确性。也就是说一笔订单，只有这两个操作都完成，才能算做处理成功，否则处理失败，充分体现了“All or nothing”的思想
而分布式事务，就是在分布式系统中运行的事务，由多个本地事务组合而成。在分布式场景下，对事务的处理操作可能来自不同的机器，甚至是来自不同的操作系统。文章开头提到的电商处理订单问题，就是典型的分布式事务

# 分布式事务三种实现方式
3种实现方式，2种理论：
+ 基于`XA`协议的二阶段提交协议方法
+ 基于`XA`协议三阶段提交协议方法
+ 基于消息的最终一致性方法

其中，基于`XA`协议的二阶段提交协议方法和三阶段提交协议方法，采用了强一致性，遵从 ACID，基于消息的最终一致性方法，采用了最终一致性，遵从 BASE 理论。

# 二阶段提交
事务管理器作为协调者，负责各个本地资源的提交和回滚，而资源管理器就是分布式事务的参与者，通常由数据库实现，比如oracle，innodb8

角色：
+ 协调者（xa）
+ 参与者（服务）

事件
+ canCommit
+ doCommit/doAbort

两个阶段：
+ 投票（voting）
+ 提交（commit）

## 投票
![8a880c358c5f1a1fe9c8cc8179d6b56a](https://raw.githubusercontent.com/1990frog/imagebed/default/1602319480_20200401131435915_1523498616.png)
协调者（Coordinator，即事务管理器）会向事务的参与者（Cohort，即本地资源管理器）发起执行操作的`CanCommit`请求，并等待参与者的响应。
参与者接收到请求后，会执行请求中的事务操作，记录日志信息但不提交，待参与者执行成功，则向协调者发送`Yes`消息，表示同意操作；若不成功，则发送`No`消息，表示终止操作。
当所有的参与者都返回了操作结果（`Yes`或`No`消息）后，系统进入了提交阶段。
## 提交
![bd73d10eb000ee554a448d169344f95c](https://raw.githubusercontent.com/1990frog/imagebed/default/1602319481_20200401131605901_1221455951.png)

在提交阶段，协调者会根据所有参与者返回的信息向参与者发送`DoCommit`或`DoAbort`指令：
+ 若协调者收到的都是`Yes`消息，则向参与者发送`DoCommit`消息，参与者会完成剩余的操作并释放资源，然后向协调者返回`HaveCommitted`消息；
+ 如果协调者收到的消息中包含`No`消息，则向所有参与者发送`DoAbort`消息，此时发送`Yes`的参与者则会根据之前执行操作时的回滚日志对操作进行回滚，然后所有参与者会向协调者发送`HaveCommitted`消息；
+ 协调者接收到`HaveCommitted`消息，就意味着整个事务结束了。

## 流程
由上述流程可以看出，二阶段提交的算法思路可以概括为：
1. 协调者下发请求事务操作
2. 参与者将操作结果通知协调者
3. 协调者根据所有参与者的反馈结果决定各参与者是要提交操作还是撤销操作

## 不足
虽然基于`XA`的二阶段提交算法基本满足了事务的`ACID`特性，但依然有些不足
### 同步阻塞问题
二阶段提交算法在执行过程中，所有参与节点都是事务阻塞型的。
也就是说，当本地资源管理器占有临界资源时，其他资源管理器如果要访问同一临界资源，会处于阻塞状态。
### 单点故障问题
基于`XA`的二阶段提交算法类似于集中式算法，一旦事务管理器发生故障，整个系统都处于停滞状态。
尤其是在提交阶段，一旦事务管理器发生故障，资源管理器会由于等待管理器的消息，而一直锁定事务资源，导致整个系统被阻塞。
### 数据不一致问题
在提交阶段，当协调者向参与者发送`DoCommit`请求之后，如果发生了局部网络异常，或者在发送提交请求的过程中协调者发生了故障，就会导致只有一部分参与者接收到了提交请求并执行提交操作，但其他未接到提交请求的那部分参与者则无法执行事务提交。
于是整个分布式系统便出现了数据不一致的问题。

# 三阶段提交方法
三阶段提交协议（Three-phase commit protocol，3PC），是对二阶段提交（2PC）的改进。

为了解决两阶段提交的同步阻塞和数据不一致问题，三阶段提交引入了超时机制和准备阶段
+ 超时机制：如果协调者或参与者在规定的时间内没有接收到来自其他节点的响应，就会根据当前的状态选择提交或者终止整个事务。
+ 准备阶段：在第一阶段和第二阶段中间引入了一个准备阶段，也就是在提交阶段之前，加入了一个预提交阶段。在预提交阶段排除一些不一致的情况，保证在最后提交之前各参与节点的状态是一致的。

也就是说，除了引入超时机制之外，3PC 把 2PC 的提交阶段一分为二，这样三阶段提交协议就有 CanCommit、PreCommit、DoCommit 三个阶段。

## CanCommit阶段
CanCommit阶段与2PC的投票阶段类似：
1. 协调者向参与者发送请求操作（CanCommit 请求），询问参与者是否可以执行事务提交操作，然后等待参与者的响应
2. 参与者收到`CanCommit`请求之后，回复`Yes`，表示可以顺利执行事务；否则回复`No`

CanCommit 阶段不同节点之间的事务请求成功和失败的流程，如下所示。
![56fe63b378ed63d24e318af22419bb7c](https://raw.githubusercontent.com/1990frog/imagebed/default/1602319482_20200401141258933_1054472022.png)

# PreCommit阶段
协调者根据参与者的回复情况，来决定是否可以进行`PreCommit`操作。

如果所有参与者回复的都是`Yes`，那么协调者就会执行事务的预执行：
+ 发送预提交请求。协调者向参与者发送`PreCommit`请求，进入预提交阶段。
+ 事务预提交。参与者接收到`PreCommit`请求后执行事务操作，并将`Undo`和`Redo`信息记录到事务日志中。
+ 响应反馈。如果参与者成功执行了事务操作，则返回`ACK`响应，同时开始等待最终指令。

假如任何一个参与者向协调者发送了`No`消息，或者等待超时之后，协调者都没有收到参与者的响应，就执行中断事务的操作：
+ 发送中断请求。协调者向所有参与者发送`Abort`消息。
+ 中断事务。参与者收到`Abort`消息之后，或超时后仍未收到协调者的消息，执行事务的中断操作。

预执行阶段，不同节点上事务执行成功和失败的流程，如下所示。

![56fe63b378ed63d24e318af22419bb7c](https://raw.githubusercontent.com/1990frog/imagebed/default/1602319482_20200401141406418_197061106.png)

# DoCommit阶段

`DoCmmit`阶段进行真正的事务提交，根据`PreCommit`阶段协调者发送的消息，进入执行提交阶段或事务中断阶段。

执行提交阶段：
+ 发送提交请求。协调者接收到所有参与者发送的 Ack 响应，从预提交状态进入到提交状态，并向所有参与者发送 DoCommit 消息。
+ 事务提交。参与者接收到 DoCommit 消息之后，正式提交事务。完成事务提交之后，释放所有锁住的资源。
+ 响应反馈。参与者提交完事务之后，向协调者发送 Ack 响应。
+ 完成事务。协调者接收到所有参与者的 Ack 响应之后，完成事务。

事务中断阶段：
+ 发送中断请求。协调者向所有参与者发送 Abort 请求。
+ 事务回滚。参与者接收到 Abort 消息之后，利用其在 PreCommit 阶段记录的 Undo 信息执行事务的回滚操作，并释放所有锁住的资源。
+ 反馈结果。参与者完成事务回滚之后，向协调者发送 Ack 消息。
+ 中断事务。协调者接收到参与者反馈的 Ack 消息之后，执行事务的中断，并结束事务。

执行阶段不同节点上事务执行成功和失败 (事务中断) 的流程，如下所示。
![56fe63b378ed63d24e318af22419bb7c](https://raw.githubusercontent.com/1990frog/imagebed/default/1602319483_20200401141438914_1527792833.png)