# 多种方式实现生产者消费者模式

多种方式实现生产者消费者模式

为什么wait()需要在同步代码块内使用，而sleep()不需要？
主要是让通信变得可靠，防止死锁或者永久等待的发生，如果我们不把wait，notify都放在代码块里面，那么很有可能在它执行位置之前，线程突然切换到一个执行notify的线程 ，这样一来，对面的第二个线程，就把所有的notify代码都执行完毕了之后又切过来执行wait，没有synchronize保护，就可以在执行wait之前突然切换过去，这样会导致执行wait的线程永远不会被唤醒。 
而sleep是针对自己单独线程的，和其他线程关系不大

为什么线程通信的方法wait(),notify()和notifyAll()被定义在Object类里？而sleep定义在Thread类里？
在java中wait，notify，notifyAll是锁级别的操作，而锁是属于每一个对象的，锁是绑定到每一个对象中，而不是线程中 ，同样的道理，我们反过来想，如果将w/n/n定义到Thread中，就会造成很大的局限性，经常我们会操作多把锁，如果定义在Thread中，就无法去实现这样灵活的逻辑了。

wait方法是属于Object对象的，那调用Thread.wait会怎么样？
Thread类非常特殊，在线程退出的时候会自动的调用notify，这样会使我们设计的流程受到干扰。

如何选择用notify还是notifyAll？

notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？
如果没有抢到，就会等待再次释放锁，或接受线程调度器的调度。

为什么弃用suspend()和resume()来阻塞线程？