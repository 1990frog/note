[TOC]

# 垃圾清除三种算法
+ Mark-Sweep（标记清除）
+ Copying（拷贝）
+ Mark-Compact（标记压缩）

# 标记阶段
创建对象时，其标记位设置为0（false）。在Mark阶段，我们将所有可到达对象（或用户可以引用的对象）的标记位设置为1（true）。现在要执行此操作，我们只需要进行图遍历，深度优先搜索方法对我们有效。在这里，我们可以将每个对象视为一个节点，然后访问从该节点（对象）可到达的所有节点（对象），并且它一直持续到我们访问了所有可到达的节点。
+ Root是一个引用对象的变量，可以通过局部变量直接访问。我们假设我们只有一个根。
+ 我们可以通过：markedBit（obj）访问对象的标记位。

# 扫描阶段
顾名思义，它“扫描”无法访问的对象，即清除所有无法访问的对象的堆内存。标记值设置为false的所有对象都从堆内存中清除，对于所有其他对象（可到达对象），标记位设置为true。
现在，所有可到达对象的标记值都设置为false，因为我们将运行算法（如果需要），我们将再次通过标记阶段来标记所有可到达对象。

# 脑图
1）所有对象的标记位都设置为false
![](https://raw.githubusercontent.com/1990frog/imagebed/default/1602318398_20200922100837751_9915.png)
2）可达对象标记为true
![](https://raw.githubusercontent.com/1990frog/imagebed/default/1602318399_20200922101332386_26387.png)
3）从堆中清除不可到达的对象
![](https://raw.githubusercontent.com/1990frog/imagebed/default/1602318400_20200922101401219_29189.png)

# 优点
+ 它处理具有循环引用的情况，即使在循环的情况下，该算法也不会以无限循环结束。
+ 在执行算法期间不会产生额外的开销。
# 缺点
+ 标记和清除方法的主要缺点是在垃圾收集算法运行时正常程序执行被暂停。
+ 另一个缺点是，在标记和扫描算法在程序上运行多次之后，可到达的对象最终被许多小的未使用的存储区域分开。请查看下图以便更好地理解。
![](https://raw.githubusercontent.com/1990frog/imagebed/default/1602318401_20200922101531048_6691.png)

这里白色块表示空闲内存，而灰色块表示所有可到达对象占用的内存。
现在，自由段（用白色表示）具有不同的大小，假设5个自由段的大小为1,1,2,3,5（单位大小）。
现在我们需要创建一个占用10个单元内存的对象，现在假设只能以连续的块形式分配内存，尽管我们有12个单元的可用内存空间，但是无法创建对象，这将导致OutOfMemory错误。这个问题被称为“碎片化”。我们在“片段”中有内存，但我们无法利用该内存空间。
我们可以通过压缩来减少碎片; 我们将内存内容混洗以将所有空闲内存块放在一起以形成一个大块。现在考虑上面的例子，在压缩之后我们有一个大小为12个单位的连续空闲内存块，所以现在我们可以将内存分配给一个大小为10个单位的对象。
