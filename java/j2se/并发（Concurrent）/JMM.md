JVM内存结构 vs Java内存模型 vs Java对象模型
三个截然不同的概念，但是很多人容易弄混
jvm内存结构，和java虚拟机的运行时区域有关
java内存模型，和java的并发编程有关
java对象模型，和java对象在虚拟机中的表现形式有关（OOP-Klass模型）



java对象模型：
java对象自身的存储模型
jvm会给这个类创建一个instanceKlass，保存在方法区，用来在jvm层表示该java类
当我们在java代码中，使用new创建一个对象的时候，jvm会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据



jvm内存结构：运行时内存分为5个部分


-------
JMM是规范
Java Memory Model

是一组规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。

如果没有这样的一个JMM内存模型来规范，那么很可能经过了不同JVM的不同规则的重排序之后，导致不同的虚拟机上运行的结果不一样，那是很大的问题。

volatile、synchronized、Lock等的原理都是JMM

如果没有JMM，那就需要我们自己指定什么时候用内存栅栏等，那是相当麻烦的，幸好有了JMM，让我们只需要用同步工具和关键字就可以开发并发程序了。

内存栅栏：工作内存和主内存之间的拷贝和同步

JMM最重要的三点内容：重排序、可见性、原子性

重排序（out of order execution）
好处：提高处理速度

重排序三种情况：编译器优化、CPU指令重拍、内存的“重排序”


重排序的好处：提高处理速度

重排序有哪3种可能性？

重排序的3种情况分别是什么？
解答：

    编译器优化
    编译器（包括JVM，JIT编译器等）出于优化的目的（例如当前有了数据a，那么如果把对a的操作放到一起效率会更高，避免了读取b后又返回来重新读取a的时间开销），在编译的过程中会进行一定程度的重排，导致生成的机器指令和之前的字节码的顺序不一致。
    在刚才的例子中，编译器将y=a和b=1这两行语句换了顺序（也可能是线程2的两行换了顺序，同理），因为它们之间没有数据依赖关系，那就不难得到 x =0，y = 0 这种结果了。
    指令重排序
    CPU 的优化行为，和编译器优化很类似，是通过乱序执行的技术，来提高执行效率。所以就算编译器不发生重排，CPU 也可能对指令进行重排，所以我们开发中，一定要考虑到重排序带来的后果。
    内存的“重排序”
    内存系统内不存在重排序，但是内存会带来看上去和重排序一样的效果，所以这里的“重排序”打了双引号。由于内存有缓存的存在，在JMM里表现为主存和本地内存，由于主存和本地内存的不一致，会使得程序表现出乱序的行为。
    在刚才的例子中，假设没编译器重排和指令重排，但是如果发生了内存缓存不一致，也可能导致同样的情况：线程1 修改了 a 的值，但是修改后并没有写回主存，所以线程2是看不到刚才线程1对a的修改的，所以线程2看到a还是等于0。同理，线程2对b的赋值操作也可能由于没及时写回主存，导致线程1看不到刚才线程2的修改。


JMM抽象：本地内存与主内存


RAM->L3->L2->L1->registers

L3会把RAM里面重要的缓存下来
。。。

为什么会有可见性问题
CPU有多级缓存，导致读的数据过期
+ 高速缓存的容量比主存小，但是速度仅次于寄存器，所以在CPU和主内存之间就多了Cache层
+ 线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的

如果所有核心都用一个缓存，那么也就不存在内存可见性问题了。
每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中。所以会导致有些核心读取的值是一个过期的值



java作为高级语言，屏蔽了这些底层细节，用JMM定义了一套读写内存数据的规范，虽然我们不再需要关系一级缓存和二级缓存的问题，但是，JMM抽象了主内存和本地内存的概念。
这里说的本地内存并不是真的是一块给每个线程分配的内存，而是JMM的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象。



Java 作为高级语言，屏蔽了CPU多层缓存这些底层细节，用 JMM 定义了一套读写内存数据的规范，虽然我们不再需要关心一级缓存和二级缓存的问题，但是，JMM 抽象了主内存和本地内存的概念。
这里说的本地内存并不是真的是一块给每个线程分配的内存，而是 JMM 的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象。

---

主内存和本地内存的关系
1、所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是内存中的拷贝
2、线程不能直接读写主内存中的变量，而是只能操作自己工作内存中的变量，然后再同步到主内存中
3、主内存是多个线程共享的，但线程间不共享工作内存，如果线程间需要通信，必须借助主内存中转来完成


主内存和本地内存的关系是什么？

JMM有以下规定:

    所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝
    线程不能直接读写主内存中的变量,而是只能操作自己工作内存中的变量，然后再同步到主内存中
    主内存是多个线程共享的，但线程间不共享工作内存,如果线程间需要通信，必须借助主内存中转来完成

所有的共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题。



在Java编程世界中，Java内存模型（Java Memory Model，简称JMM）和Java虚拟机（Java Virtual Machine，简称JVM）的内存结构是两个核心概念。它们对于理解Java程序的执行方式、性能优化以及并发编程至关重要。尽管这两个概念紧密相连，但它们的职责和特性却各不相同。本文将详细探讨Java内存模型与Java虚拟机的内存结构，以便更深入地理解它们之间的关系和差异。
1️内存模型（JMM）

Java内存模型（Java Memory Model，简称JMM）是用于描述Java程序中多线程并发访问共享内存时的规范。它定义了一组规则或规范，通过这组规范来定义程序中各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式。
1.1 JMM的三个特性

JMM主要围绕可见性、原子性和有序性这三个特性而建立。具体来说：
共享变量与可见性

在Java程序中，多个线程可能同时访问和修改共享变量。为了确保每个线程都能看到其他线程对共享变量所做的修改，Java内存模型提供了一系列规则。例如，volatile关键字可以确保变量的可见性，即当一个线程修改了一个volatile变量的值后，其他线程能够立即看到这个修改。此外，synchronized块也可以保证可见性，它确保在进入和退出synchronized块时，线程对共享变量的操作对其他线程是可见的。
有序性

为了优化程序性能，编译器和处理器可能会对指令进行重排序。然而，这种重排序可能会导致多线程程序出现意想不到的结果。为了解决这个问题，Java内存模型定义了happens-before规则来确保多线程之间的操作顺序符合预期。简单来说，如果一个操作happens-before另一个操作，那么第一个操作的结果将对第二个操作可见。
原子性

Java内存模型还规定了某些操作具有原子性。原子性意味着这些操作在执行过程中不会被其他线程中断。例如，对volatile变量的读写操作具有原子性。但是，需要注意的是，并非所有操作都具有原子性。对于非原子性操作，我们需要使用锁等机制来保证线程安全。

1.2 主内存和工作内存

此外，JMM还定义了主内存和工作内存的概念：

    主内存是线程间共享的内存区域，所有线程都可以访问。
    工作内存是每个线程私有的内存区域，用于存储主内存中共享变量的副本。
    线程对变量的操作必须在工作内存中进行，不能直接操作主内存中的变量，操作完成后，再将变量写回主内存。

总的来说，Java内存模型是一种抽象的概念，它描述了程序中各个变量之间的关系以及在计算机系统中将变量存储到内存和从内存中取出变量的底层细节。JMM的存在主要是为了屏蔽不同硬件和操作系统之间的差异，使得Java程序能够在不同的平台上达到一致的内存访问结果。

2虚拟机的内存结构

Java虚拟机的内存结构主要描述了虚拟机在执行Java程序时所使用的内存空间组织方式。它包括以下几个部分：
2.1 堆内存（Heap）

堆内存是Java虚拟机中用于存储对象实例和数组的内存区域。它是所有线程共享的，因此也是垃圾回收器管理的主要区域。堆内存的大小可以在虚拟机启动时通过参数进行配置。在堆内存中分配的对象，只要不被垃圾回收器回收，就可以被任何线程访问。堆内存可以进一步细分为新生代和老年代，分别用于存储新创建的对象和存活时间较长的对象。
2.2 栈内存（Stack）

每个线程在创建时都会分配一个私有的栈空间，用于存储局部变量、操作数栈、动态链接和方法出口等信息。栈内存中的数据只能在当前线程中访问，其他线程无法直接访问。栈内存的大小也可以在虚拟机启动时通过参数进行配置。当线程调用一个方法时，会在栈内存中创建一个栈帧来存储该方法的相关信息。方法执行完毕后，栈帧会被弹出栈，释放相应的内存空间。
2.3 方法区（Method Area）

方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。与堆内存一样，方法区也是由所有线程共享的。不过，需要注意的是，在Java虚拟机规范中并未明确规定方法区的具体实现方式。在HotSpot虚拟机中，方法区被实现为永久代（PermGen space），但在Java 8及以后的版本中，永久代被元空间（Metaspace）所取代。
2.4 程序计数器（Program Counter Register）

程序计数器是一个较小的内存空间，用于存储当前线程正在执行的字节码的地址。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
3️JMM与JVM内存结构的关系

Java内存模型和Java虚拟机的内存结构是两个相互独立但又密切相关的概念。

    JMM主要关注多线程对共享变量的访问和修改行为以及相关的可见性、有序性和原子性问题；

    而JVM的内存结构则描述了虚拟机在执行Java程序时所使用的内存空间组织方式以及各个内存区域的作用和特性。

在实际应用中，我们需要同时理解这两个概念才能更好地掌握Java并发编程和性能优化的核心技术。

例如，在使用锁和并发容器时，我们需要了解它们在JMM中的行为以及它们是如何利用JVM的内存结构来实现线程安全和高效并发的。同时，我们还需要关注JVM的垃圾回收机制以及它对堆内存的管理方式以避免内存泄漏和性能下降等问题。
4️总结

本文详细探讨了Java内存模型与Java虚拟机的内存结构之间的关系和差异。通过深入理解这两个概念以及它们在实际应用中的作用和特性，我们可以更好地掌握Java并发编程的核心技术并编写出高效、线程安全的程序。在未来的Java开发中无论面对复杂的并发场景还是性能优化挑战我们都将受益于对JMM和JVM内存结构的深入理解。

-----

Happens-before

什么是happens-before
1、happens-before规则是用来解决可见性问题的：在时间上，动作A发生在动作B之前，B保证能看到A，这就是happens-before。
2、两个操作可以用happens-before来确定他们的执行顺序：如果一个操作happens-before于另一个操作，那么我们说第一个操作对于第二个操作是可见的。