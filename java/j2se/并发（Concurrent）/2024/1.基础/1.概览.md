<!-- TOC -->

- [为什么需要多线程？](#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B)
- [IO 密集型](#io-%E5%AF%86%E9%9B%86%E5%9E%8B)
- [CPU 密集型](#cpu-%E5%AF%86%E9%9B%86%E5%9E%8B)
- [进程](#%E8%BF%9B%E7%A8%8B)
- [进程与线程类比](#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%B1%BB%E6%AF%94)

<!-- /TOC -->
# 为什么需要多线程？
提高资源的利用率

如果一个程序允许两个或以上的线程，那么它就是多线程程序。多线程是指在单个进程中运行的多个线程。

一对一映射到操作系统的内核线程（有些语言的线程是虚拟线程，它不会在操作系统中对应的去创建线程，在java中我们创建100个线程就会实实在在的看到多出来100个线程）

# IO 密集型
I/O密集型：当线程等待时间所占比例越高，需要越多线程，启用其他线程继续使用CPU，以此提高CPU的利用率；

CPU密集型，也叫计算密集型，一般是指服务器的硬盘、内存硬件性能相对CPU好很多，或者使用率低很多。系统运行CPU读写I/O(硬盘/内存)时可以在很短的时间内完成，几乎没有阻塞（等待I/O的实时间）时间，而CPU一直有大量运算要处理，因此CPU负载长期过高。

CPU密集几乎无I/O阻塞，CPU一直会全速运行。如果是单核情况下，开多线程是没有意义的，说白了就是一个CPU来回切着运行而已，徒增线程切换的资源消耗，卵用没有。可见，CPU密集任务只有在多核CPU上、开多线程才可能提速。

CPU使用率较高时（如我们训练算法模型、搞训练集），通常线程数只需要设置为CPU核心数的线程个数就可以了。单CPU对应单线程效率最高。

一般其计算公式可遵循：CPU密集型核心线程数 = CPU核数。

# CPU 密集型
CPU密集型：当线程CPU时间所占比例越高，需要越少的线程。任务越多，花在进程、线程切换的时间就越多，通常线程数和CPU核数一致即可，这一类型在开发中主要出现在一些计算业务频繁的逻辑中。

I/O密集型任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（磁盘I/O远低于内存、CPU速度）。涉及到网络、磁盘I/O的任务多是I/O密集型任务。I/O密集型任务，线程数越多，CPU效率越高，但也有相对限度。

I/O密集型相反，一般是指服务器CPU的性能相对硬盘、内存硬件好很多，或者使用率低很多。系统运行多是CPU在等I/O (硬盘/内存) 的读写操作，此类情景下CPU负载并不高。

I/O密集型的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而程序的逻辑做得并不好，没有充分利用CPU能力，导致线程空余时间很多。通常我们会开CPU核心数数倍的线程，在线程进行 I/O 操作 CPU 空闲时，启用其他线程继续使用 CPU，以提高 CPU 的使用率，充分利用CPU资源。

一般其计算公式可遵循：I/O密集型核心线程数 = CPU核数 / （1-阻塞系数）。

阻塞系数在在0到1范围内。一般为0.8~0.9之间，也可以取0.8或者0.9。对于双核CPU来说，它比较理想的线程数就是20，当然这都不是绝对的，需要根据实际情况以及实际业务来调整。

# 进程
+ 进程是拥有独立功能的一个程序运行起来的一个活动，是一个实例；它也是我们系统分配资源和调度的独立的单位
+ 线程是CPU的独立调度单位
+ 对应进程而言，不同的进程之间它们都会被操作系统分配内存，但是不同进程的内存通常是不共享的，比如说我们的浏览器无法访问播放音乐的软件的内存。它们要是想要通信，除非使用高级技巧，叫做进程间通信IPC。而线程与线程之间，它们共享就容易多了，因为它们都服务于同一个进程。它们可以直接访问一定量的共享内存，不需要任何额外的处理
  

# 进程与线程类比
例子1
+ 客厅（进程）
+ 厕所（互斥锁）
+ 独立房间（每一个线程用有的独立资源）
+ 花园浇水（合作）

例子2
+ 大火锅一人吃（单进程单线程）
+ 大火锅多人吃（单进程多线程）
+ 单独吃小火锅（多进程）

