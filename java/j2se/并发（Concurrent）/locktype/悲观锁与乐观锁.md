[TOC]

# 概览
+ Synchronized和Lock属于悲观锁
+ CAS属于乐观锁

# 核心思想
+ 悲观锁：悲观地认为程序中的`并发情况严重`，所以严防死守
+ 乐观锁：乐观地认为程序中的`并发情况不那么严重`，所以让线程不断去尝试更新

# 使用场景
+ 悲观锁：Synchronized同步锁更适合在并发量非常高的情况下
+ 乐观锁：CAS机制用于如Atomic系列类，Lock系列类的底层实现
补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 `偏向锁` 和 `轻量级锁` 以及其它各种优化之后变得在某些情况下并不是那么重了。
synchronized的底层实现主要依靠 `Lock-Free` 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。
在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。

# CAS
CAS机制当中使用了3个基本操作数：
+ 内存地址V
+ 旧的预期值A
+ 要修改的新值B

当且仅当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B

# CAS的缺点
1. CPU开销较大
在并发量比较高的情况下，如果许多线程反复尝试更新某个变量，却一直不成功，循环往复，会给CPU带来很大的压力。
2. 不能保证代码块的原子性
<font color="red">CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性</font>
比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了
3. ABA问题
当一个值从A更新成B，又更新会A，普通CAS机制会误判通过检测。

## 例
假设内存中有个值为100的变量，存储在地址V中。

此时有3个线程想使用CAS的方式更新这个值，每个线程执行的时间有略微的偏差。线程1和线程2已经获得当前值，线程3还未获得当前值。即：
+ 线程1：获取当前值100，期望更新为50；
+ 线程2：获取当前值100，期望更新为50；
+ 线程3：期望更新为100；

之后，线程1先执行成功，把100更新为50，线程2因为某些原因被阻塞，未做更新；线程3在1更新后，获得当前值50.

+ 线程1：获取当前值100，成功更新为50；
+ 线程2：获取当前值100，期望更新为50，BLOCK；
+ 线程3：获取当前值50，期望更新为100；

此时，线程2仍处于阻塞状态，线程3继续执行，把50更新为100。

+ 线程1：获取当前值100，成功更新为50，已返回；
+ 线程2：获取当前值100，期望更新为50，BLOCK；
+ 线程3：获取当前值50，成功更新为100；

最后，线程2终于恢复运行状态，由于阻塞之前已经获得“当前值”100，并经过compare检测，内存地址V的实际值也是100，所以成功把变量100更新为50.

+ 线程1：获取当前值100，成功更新为50，已返回；
+ 线程2：获取当前值100，成功更新为50；
+ 线程3：获取当前值50，成功更新为100，已返回；

这个过程中，线程2获取到的变量100是一个旧值，尽管和当前的实际值相同，但内存地址V中的变量已经经历了100->50->100（即A->B->A)的改变。

## 解决方案
利用版本号比较可以有效解决ABA问题。即，在Compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。
在Java当中，Java并发包中提供了一个带有标记的原子引用类AtomicStampedReference，其可以通过控制变量值的版本来保证CAS的正确性。

# 悲观锁
如果我不锁住这个资源，别人就回来争抢，就会造成数据结果错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失

# 悲观锁缺点
+ 阻塞和唤醒带来的性能劣势（排队）
+ 永久阻塞：如果持有锁的线程被永久阻塞，比如遇到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的那几个悲催的线程，将永远也得不到执行
+ 优先级反转（优先级翻转是当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证）

# 乐观锁：Atomic原子类、并发容器
+ 如果数据和我一开始拿到的不一样了，说明其他人在这段时间内改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃、报错、重试等策略
+ 乐观锁的实现一般都是利用CAS算法来实现的（乐观锁一般会使用版本号机制或CAS（Compare-And-Swap，即比较并替换）算法实现）

例子1：
1. 线程1发现没人在计算期间修改资源，于是把自己的计算结果写到资源里
2. 线程2计算完并判断资源是否已被修改，发现计算期间有人修改了资源，于是报错或重试

例子2：
Git就是乐观锁的典型例子
当我们往远端仓库push的时候，git会检查远端仓库版本是不是领先于我们现在的版本
如果远程仓库的版本号和本地的不一样，就表示有其他人修改了远端代码了，我们的这次提交就失败
如果远端和本地版本号一致，我们就可以顺利提交版本到远端仓库。git不适合用悲观锁，否则公司倒闭（只能一个人用）

# 版本号机制
举一个版本号的例子：
数据表存在一个version字段，更新数据时version字段会加1
假设：线程A在读取数据和version(version = 1)的期间，线程B也读取了version(version = 1)
线程A修改数据，更新version(version = 2)，在更新version前读取的version(version = 1)和当前数据表中的version(version = 1)相同，则更新成功
线程B也修改数据，更新version(version = 2)提交更新时，由于读取时version = 1 而当前数据表version = 2 不相等，则更新失败
```sql
select version from table;
update set num=2,version=version+1 where version=1 and id=5;
```
不使用版本号机制：
```sql
select for update
```

# 乐观锁的缺点
## ABA问题
如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？
很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题。

JDK 1.5以后的AtomicStampedReference类就提供了此种能力，其中的compareAndSet方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
## 循环时间长开销大
自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

目前新版本JVM可以将自旋太久的线程设置为阻塞
## 只能保证一个共享变量的原子操作
CAS只对单个共享变量有效，当操作涉及跨多个共享变量时CAS无效。
但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。
# 开销对比
+ 悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响【阻塞的优点？】
+ 相反，虽然乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多
<font color="red">疑问：阻塞会释放cpu资源？自旋持有cpu资源？线程唤醒的过程是怎么样的？</font>


