阻塞、非阻塞和同步、异步其实针对的对象是不一样的。
阻塞、非阻塞说的是调用者;
同步、异步说的是被调用者。

同步请求，A调用B，B的处理是同步的，在处理完之前他不会通知A，只有处理完之后才会明确的通知A。
异步请求，A调用B，B的处理是异步的，B在接到请求后先告诉A我已经接到请求了，然后异步去处理，处理完之后通过回调等方式再通知A。
所以说，同步和异步最大的区别就是被调用方的执行方式和返回时机。同步指的是被调用方做完事情之后再返回，异步指的是被调用方先返回，然后再做事情，做完之后再想办法通知调用方。

阻塞请求，A调用B，A一直等着B的返回，别的事情什么也不干。
非阻塞请求，A调用B，A不用一直等着B的返回，先去忙别的事情了。
所以说， 阻塞和非阻塞最大的区别就是在被调用方返回结果之前的这段时间内，调用方是否一直等待。阻塞指的是调用方一直等待别的事情什么都不做。非阻塞指的是调用方先去忙别的事情。

---

# 生活场景：当我们去饭店吃饭时
+ 食堂排队打饭模式：排队在窗口，打好就走
+ 点单、等待被叫模式：等待被叫，好了自己去端
+ 包厢模式：点单后菜直接被端上桌

## 类比
+ 饭店：服务器
+ 饭菜：数据
+ 饭菜好了：数据就绪
+ 端菜/送菜：数据读取

|      情景       |      模型      |    版本    |
| -------------- | ------------- | --------- |
| 排队打饭模式      | BIO（阻塞IO）   | jdk1.4之前 |
| 点单、等待被叫模式 | NIO（非阻塞IO） | jdk1.4    |
| 包厢模式         | AIO（异步IO）   | jdk1.7    |


# 阻塞与非阻塞
+ 菜没好，要不要一直等：数据就绪前要不要等待
+ 阻塞：没有数据传过来时，读就会阻塞直到有数据；缓存区满时，写操作也会阻塞

# 同步与异步
+ 菜好了，谁端：数据就绪后，数据操作谁完成
+ 数据就绪后需要自己去读是同步，数据就绪直接读好再回调给程序是异步


# 为什么不建议阻塞IO（BIO/OIO）
连接数高的情况下：阻塞消耗大量资源，效率低

# 为什么删掉已经做好的AIO支持？
+ windows实现成熟，但是很少用来做服务器
+ Linux常用来做服务器，但是AIO实现不够成熟
+ Linux下AIO相比较NIO的性能提升不明显

# NIO一定优于BIO吗？
+ BIO代码更简单
+ 特点场景：连接数少，并发度低，BIO性能不输NIO

