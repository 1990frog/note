[TOC]

# 创建线程只有一种方法
```java
new Thread().start();
```
其start()方法调用native start0()，产生一个新的线程
# 绑定线程算法（实现线程的执行单元）的几种方式
都是Runnable的花式玩法
## 实现Runnable接口（正规定义函数方式）
实现Runnable接口，重写run()函数，将实例传递给Thread对象，由其run方法调用
```java
Thread thread = new Thread(new Runnable(){......});
thread.start();

class Thread{
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
}
```
## 继承Thread类，重写run方法（顺途同归）
与第一种殊途同归，第一种是通过指针绑定Runnable的run，而第二种是直接将算法覆盖
```java
new Thread{

    @Override
    public void run() {
        //具体算法实现
    }
}.start();
```
## Lumbda表达式（Runnable是函数式接口）
就是传递Runnable的另一种表达形式，本身Runnable就是函数式接口
## 匿名内部类（接口匿名实现）
Lumbda就是它的套娃，可以看一下编译之后的class文件
## 线程池（线程池ThreadFactory负责创建Thread然后执行run）
线程池本身负责创建Thread，算法是通过绑定不同的run方法实现重复利用线程
## TimerTask定时器（继承Runnable）
继承Runnable接口，实现套娃
```java
interface TimerTask implements Runnable
```
## 通过Callable和FutureTask创建线程（继承Runnable）
套娃
```java
interface FutureTask<V> implements RunnableFuture<V>
interface RunnableFuture<V> extends Runnable, Future<V>
```


