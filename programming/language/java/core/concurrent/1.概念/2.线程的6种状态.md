[TOC]

垃圾的很

# 线程的6种状态
![线程的6个状态](https://gitee.com/caijingquan/imagebed/raw/master/1602317475_20191125135006853_659645966.png)

## New
已创建，但没启动，未执行Run方法
## Runnable（Running，Ready）
调用了start方法，未分配资源也是此状态，Runnable可运行的，也可能是已运行中的（yield也是这种状态）
## Blocked
阻塞状态，是线程在等待锁的状态
进入synchronized修饰的代码块，等待获取互斥锁
## Waiting
调用了wait()，join()，LockSupport.park()方法
waiting状态会释放锁
## Timed Waiting
调用了sleep(time)，wait(time)，join(time)，LockSupport.parkNanos(time)，LockSupport.parkUntl(time)方法，进入计时等待状态
并不会释放锁
## Terminated [ˈtɜːmɪneɪtɪd]
终止状态，RUNNABLE执行完成，或出现异常

# 阻塞状态
阻塞状态：一般习惯而言，把Blocked（被阻塞）、Waiting（等待）、Timed_waiting（计时等待）都称为阻塞状态

线程的资源有不少，但应该包含CPU资源和锁资源这两类。
+ sleep(long mills)：让出CPU资源，但是不会释放锁资源。
+ wait()：让出CPU资源和锁资源。

锁是用来线程同步的，sleep(long mills)虽然让出了CPU，但是不会让出锁，其他线程可以利用CPU时间片了，但如果其他线程要获取sleep(long mills)拥有的锁才能执行，则会因为无法获取锁而不能执行，继续等待。
但是那些没有和sleep(long mills)竞争锁的线程，一旦得到CPU时间片即可运行了。

# Blocked对比Waiiting
假设t1，t2先后两个线程，都执行如下代码：
```java
synchronized(obj) {
    obj.wait();
}
```
t1先获取锁，执行代码，最后在obj.wait()下卡住，这时java管t1的状态waitting状态
t2无法获取锁，直接在第一行就卡住了，这时java叫t2为blocked状态

请注意，<font color="red">blocked是过去分词，意味着他是被卡住的</font>。因为这段代码只让一条线程运行。同时，jvm是知道怎么结束blocked的，只要别的线程退出这段代码，他就会自动让你进去。也就是说别的线程无需唤醒你，由jvm自动来干。

而waiiting是说我调用wait()等函数，主动卡住自己，请jvm在满足某种条件后，比如另条线程调用了notify()后，把我唤醒。这个唤醒的责任在于别的线程明确的调用一些唤醒函数。

做这样的区分，是jvm出于管理的需要，做了这种区分，比如两个原因的线程放两个队列里管理，如果别的线程运行出了synchronized这段代码，我只需要去blocked队列，放个出来。而某人调用了notify()，我只需要去waitting队列里取个出来。

P.S. 从linux内核来看，这些线程都是等待状态，没区别，区别只在于java的管理需要。通常我们在系统级别说线程的blocked，是说线程操作io，被暂停了，这种线程由linux内核来唤醒（io设备报告数据来了，内核把block的线程放进可运行的进程队列，依次得到处理器时间），而wait是说，等待一个内核mutex对象，另个线程signal这个mutex后，这个线程才可以运行。区别在于由谁唤醒，是操作系统，还是另一个线程，这里倒和java很相似。



![](https://gitee.com/caijingquan/imagebed/raw/master/https://gitee.com/caijingquan/imagebed/20211114220512.jpg)

+ New:当我们构造出一个线程实例的时候, 这个线程就拥有了 New 状态。这个状态是线程的第一个状态。此时，线程并没有准备运行。

+ Runnable:当调用了线程类的 start() 方法, 那么这个线程就会从 New 状态转换到 Runnable 状态。这就意味着这个线程要准备运行了。但是，如果线程真的要运行起来，就需要线程调度器来调度执行这个线程。但是线程调度器可能忙于在执行其他的线程，从而不能及时去调度执行这个线程。线程调度器是基于 FIFO 策略去从线程池中挑出一个线程来执行的。Blocked:线程可能会因为不同的情况自动的转为 Blocked 状态。比如，等候 I/O 操作，等候网络连接等等。除此之外，任意的优先级比当前正在运行的线程高的线程都可能会使得正在运行的线程转为 Blocked 状态。

Waiting:在同步块中调用被同步对象的 wait 方法，当前线程就会进入 Waiting 状态。如果在另一个线程中的同一个对象被同步的同步块中调用 notify()/notifyAll()，就可能使得在 Waiting 的线程转入 Runnable 状态。

Timed_Waiting:同 Waiting 状态，只是会有个时间限制，当超时了，线程会自动进入 Runnable 状态。

Terminated:线程在线程的 run() 方法执行完毕后或者异常退出run()方法后，就会进入 Terminated 状态。


waiting 让出锁，timed_waiting 不会让出锁