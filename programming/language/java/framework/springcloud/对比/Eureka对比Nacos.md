[TOC]

# Eureka对比Nacos
|    #    |                  Nacos                  |   Eureka    |
| ------ | --------------------------------------- | ----------- |
| 维护    | 还活着呢                                  | 停止维护     |
| 集成支持 | Dubbo、SpringCloud、K8S                   | SpringCloud |
| 访问协议 | 现在支持的协议越来越多了：HTTP，动态DNS/UDP... | HTTP        |
| ACP原则 | AP、CP                                     | AP          |

nacos可以实现服务之间个隔离（元数据），namespace
nacos可以将配置信息缓存到mysql中
nacos=(eureka+config)

# 性能对比
都是相对于几千几万服务来对比的，所以....


# CAP
+ Consistency：一致性，写操作之后的读操作，必须返回该值
+ Availability：可用性，没有leader,可以很容易的切换到可用的注册中心,对于客户端的调用总是及时反应
+ Partition tolerance：分区容错性，在整个分布式系统中某个节点服务挂掉了,并不影响整个系统的运作和使用，因为他可以在稍后或者通过切换可用节点立即恢复使用

## CP
注册中心集群中: leader的作用, 所有的写操作都依赖于leader来完成,为了保证数据的一致性, leader只有一个

假如:
没有leader,首先加入我们新加入一台数据处理服务,就会像注册中心1进行注册,注册中心1写入数据处理服务的ip等等基本信息,并且准备同步给其他注册中心节点, 结果这个在还没发生同步的过程中,注册中心1挂掉了,然后客户端准备调用数据中心写入,这个时候就因为注册中心1挂掉了,就直接切到了注册中心2,但是注册中心2没有收到数据处理服务的添加请求,所有没有这个服务,这个时候就对客户端显示不可用了

## AP
在上述CP操作的例子中,对于像服务注册,获取服务注册的基本信息,比如ip来说,基本不会存在,因为像Eureka来说,我们的服务可以像所有的注册中心节点发起注册请求, 这样就不会存在注册中心节点服务列表不一致的情况

# eureka config
单独服务,是从git仓库拉取配置信息,然后服务端从config服务里面拉取配置信息缓存到本地仓库,这里配置的变更比较麻烦,他需要结合bus组件,同时约束了只能用rabbitmq和kafka来进行通知服务端进行配置变更,但是保证了数据的一致性,因为他的配置信息在git仓库上,git仓库只有一个,就会数据一致

# nacos可以实现服务隔离

# nacos可以配置权重

# nacos可以优雅的下线