[TOC]

协程不是计算机提供
协程也叫微线程

协程就是一个线程在代码之间切换运行

协程（Coroutine），也可以被称为微线程，是一种用户态内的上下文切换技术。简而言之，其实就是通过一个线程实现代码块相互切换执行

```python
def func1():
    print(1)
    ...
    print(2)

def func2():
    print(3)
    ...
    print(4)

func1()
func2()
```

# 实现协程方法
+ greenlet，早期模块
+ yield关键字
+ asyncio装饰器(py3.4+)
+ async、await关键字(py3.5+)【主流推荐】

## greenlet
`pip3 install greenlet`

```python
from greenlet import greenlet

def func1():
    print(1)
    fr2.switch()
    print(2)
    fr2.switch()

def func2():
    print(3)
    fr1.switch()
    print(4)
    fr1.switch()

gr1 = greenlet(func1)
gr2 = greenlet(func2)
gr1.switch()

输出1，3，2，4
```

## yield关键字

```python
def func1():
    yield 1
    yield from func2()
    yield 2

def func2():
    yield 3
    yield 4

f1 = func1()
for item in f1:
    print(item)
```

## asyncio

```python
import asyncio

@asyncio.coroutine
def func1():
    print(1)
    yield from asyncio.sleep(2) # 遇到IO耗时操作，自动化切换到tasks中的其他任务
    print(2)

@asyncio.coroutine
def func2():
    print(3)
    yield from asyncio.sleep(2) # 遇到IO耗时操作，自动化切换到tasks中的其他任务
    print(4)

tasks = [
    asyncio.ensure_future(func1()),
    asyncio.ensure_future(func2())
]

loop = asyncio.get_event_loop()
loop.run_util_complete(asyncio.wait(tasks))
```

# async & await 关键字

```python
async def func1():
    print(1)
    await asyncio.sleep(2) # 遇到IO耗时操作，自动化切换到tasks中的其他任务
    print(2)

async def func2():
    print(3)
    await asyncio.sleep(2) # 遇到IO耗时操作，自动化切换到tasks中的其他任务
    print(4)

tasks = [
    asyncio.ensure_future(func1()),
    asyncio.ensure_future(func2())
]

loop = asyncio.get_event_loop()
loop.run_util_complete(asyncio.wait(tasks))
```

# 总结
在一个线程中如果遇到IO等待时间，线程不会傻等，利用空闲的时间去做其他的事

# 协程能否完全替代线程


# 快速上手
```python
import asyncio

# 协程函数
async def func():
    pass

# 协程对象
# 执行协程函数创建协程对象，函数内部代码不会执行
# 如果想要运行协程函数内部代码，必须要讲协程对象交给事件循环来处理
result = func()

# 写法1
# 去生成或获取一个事件循环
# 将任务放到循环事件中
loop = asyncio.get_event_loop()
loop.run_unit_complete(result)

# 写法2 py3.7+
asyncio.run(result)
```