<!-- TOC -->

- [用 enum 代替 int 常量](#%E7%94%A8-enum-%E4%BB%A3%E6%9B%BF-int-%E5%B8%B8%E9%87%8F)
    - [枚举特定行为](#%E6%9E%9A%E4%B8%BE%E7%89%B9%E5%AE%9A%E8%A1%8C%E4%B8%BA)
- [用实例域代替序数](#%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%9F%9F%E4%BB%A3%E6%9B%BF%E5%BA%8F%E6%95%B0)
- [用 EnumSet 代替位域](#%E7%94%A8-enumset-%E4%BB%A3%E6%9B%BF%E4%BD%8D%E5%9F%9F)
- [用 EnumMap 代替序数索引](#%E7%94%A8-enummap-%E4%BB%A3%E6%9B%BF%E5%BA%8F%E6%95%B0%E7%B4%A2%E5%BC%95)
- [用接口模拟可扩展的枚举](#%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%A8%A1%E6%8B%9F%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E6%9E%9A%E4%B8%BE)
- [注解优先于命名模式](#%E6%B3%A8%E8%A7%A3%E4%BC%98%E5%85%88%E4%BA%8E%E5%91%BD%E5%90%8D%E6%A8%A1%E5%BC%8F)
- [坚持使用 Override 注解](#%E5%9D%9A%E6%8C%81%E4%BD%BF%E7%94%A8-override-%E6%B3%A8%E8%A7%A3)
- [用标记接口定义类型](#%E7%94%A8%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B)

<!-- /TOC -->

Java 支持两种特殊用途的引用类型：一种是类，称作枚举类型（enum type）；一种是接口，称作注解类型（annotation type）。

# 用 enum 代替 int 常量
```java
// 常量，缺陷：不具有类型安全性，不能遍历全部同类型常量，同类型没有独立的命名空间
public static final int APPLE_FUJI = 0;
public static final int APPLE_PIPPIN = 1;
public static final int APPLE_GRANNY_SMITH = 2;
// 枚举
public enum APPLE {FUJI,PIPPIN,GRANNY_SMITH}
```

枚举
1. 这些类通过公有的静态 final 域为每个枚举常量导出一个实例。枚举类型没有可以访问的构造器，所以它是真正的 final 类。客户端不能创建枚举类型的实例，也不能对它进行扩展，因此不存在实例，而只存在声明过的枚举常量。换句话说，枚举类型是实例受控的。它们是单例的泛型化，本质上是单元素的枚举。
2. 枚举类型保证了编译时类型安全。例如声明参数的类型为Apple，它就能保证传到该参数上的任何非空的对象引用一定属于三个有效的Apple值之一，而其他任何试图传递类型错误的值都会导致编译时错误，就像试图将某种枚举类型的表达式赋予给另一种枚举类型的变量，或者试图利用 == 操作符比较不同枚举类型的值都会导致编译时错误。
3. 包含同名常量的多个枚举类型可以在一个系统中和平共处，因为每个类型都有自己的命名空间。
4. 除了完善 int 枚举模式的不足之外，枚举类型还允许添加任意的方法和域，并实现任意的接口。它们提供了所有 Object 方法的高级实现，实现了 Comparable 和 Serializable 接口，并针对枚举类型的可任意改变性设计了序列化方式。
5. 为了将数据域枚举常量关联起来，得声明实例域，并编写一个带有数据并将数据保存在域中的构造器。枚举天生就是不可变的，因此所有的域都应该为 final 的。它们可以是公有的，但最好将它们做成私有的，并提供公有的访问方法。
6. 枚举有一个静态的 values 方法，按照声明顺序返回它的值数组。
7. 如果一个枚举具有普遍实用性，它就应该成为一个顶层类（top-level class）；如果它只是被用在一个特定的顶层类中，它就应该成为该顶层类的一个成员类。
8. 枚举类型有一个自动产生的valueOf(String)方法，它将常量的名字转换成常量本身。

## 枚举特定行为
在枚举类型中声明一个抽象方法，并在特定于常量的类主体（constant-specific class body）中，用具体的方法覆盖每个常量的抽象方法。这种方法被称作特定于常量的方法实现（constant-specific method implementation）。枚举类型中的抽象方法必须被它的所有常量中的具体方法所覆盖。




它存在着许多不足。int枚举模式不具有类型安全性，也几乎没有描述性可言。例如将 apple 传入到想要 orange 的方法中，编译器也不会发出警告。

# 用实例域代替序数


# 用 EnumSet 代替位域

# 用 EnumMap 代替序数索引

# 用接口模拟可扩展的枚举

# 注解优先于命名模式

# 坚持使用 Override 注解

# 用标记接口定义类型