[TOC]

在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的
InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的每一个索引在InnoDB里面对应一棵B+树

假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引
这个表的建表语句是：
```sql
 create table T(
id int primary key,
k int not null,
name varchar(16),
index (k)
)engine=InnoDB;
```

表中 R1~R5 的 (ID,k)值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。
![](https://gitee.com/caijingquan/imagebed/raw/master/1602319717_20200403121703904_1833183201.png)

从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引：
+ 主键索引的叶子节点存的是整行数据。在 InnoDB里，主键索引也被称为聚簇索引（clustered index）。
+ 非主键索引的叶子节点内容是主键的值。在 InnoDB里，非主键索引也被称为二级索引（secondary index）。

基于主键索引和普通索引的查询有什么区别？
如果语句是`select * from T where ID=500`即主键查询方式
1. 只需要搜索ID这棵B+树
如果语句是`select * from T where k=5`，即普通索引查询方式
1. 先搜索k索引树，得到 ID 的值为 500
2. 再到 ID 索引树搜索一次,这个过程称为回表。也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

# 维护索引
B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。

以上面这个图为例
如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。
如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。
而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。
这个过程称为页分裂。在这种情况下，性能自然会受影响。
除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。
当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

基于上面的索引维护过程说明，我们来讨论一个案例：你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。
当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。

自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的：`NOT NULL PRIMARY KEY AUTO_INCREMENT`
插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。
也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。
每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。

除了考虑性能外，我们还可以从存储空间的角度来看。
假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？
由于每个非主键索引的叶子节点上都是主键的值。
如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。
所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。

有没有什么场景适合用业务字段直接做主键的呢？
还是有的。比如，有些业务的场景需求是这样的：只有一个索引；该索引必须是唯一索引。
你一定看出来了，这就是典型的`KV`场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。
这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。

小结今天，我跟你分析了数据库引擎可用的数据结构，介绍了InnoDB采用的B+树结构，以及为什么InnoDB要这么选择。B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。由于InnoDB是索引组织表，一般情况下我会建议你创建一个自增主键，这样非主键索引占用的空间最小。
但事无绝对，我也跟你讨论了使用业务逻辑字段做主键的应用场景。

对于上面例子中的InnoDB表T，如果你要重建索引k，你的两个SQL语句可以这么写：
```sql
alter table T drop index k;
alter table T add index(k);
```
如果你要重建主键索引，也可以这么写：
```sql
alter table T drop primary key;
alter table T add primary key(id);
```

# 分析
在下面这个表 T 中，如果我执行`select * from T where k between 3 and 5`，需要执行几次树的搜索操作，会扫描多少行？下面是这个表的初始化语句。

```sql
create table T (
ID int primary key,
k int NOT NULL DEFAULT 0,
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

现在，我们一起来看看这条 SQL 查询语句的执行流程：
1. 在 k 索引树上找到 k=3 的记录，取得 ID = 300
2. 再到 ID 索引树查到 ID=300 对应的 R3
3. 在 k 索引树取下一个值 k=5，取得 ID=500
4. 再回到 ID 索引树查到 ID=500 对应的 R4
5. 在 k 索引树取下一个值 k=6，不满足条件，循环结束

在这个过程中，回到主键索引树搜索的过程，我们称为回表。
可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。
<font color="red">在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。</font>

那么，有没有可能经过索引优化，避免回表过程呢？
