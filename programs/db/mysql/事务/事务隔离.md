[TOC]

# 隔离性与隔离级别
提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中 I，也就是“隔离性”。

当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。

在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。

# 隔离级别
SQL 标准的事务隔离级别包括：
|        事务隔离级别         |                                                     解释                                                     |
| ------------------------- | ----------------------------------------------------------------------------------------------------------- |
| 读未提交（read uncommitted） | 一个事务还没提交时，它做的变更就能被别的事务看到                                                                     |
| 读提交（read committed）     | 一个事务提交之后，它做的变更才会被其他事务看到                                                                       |
| 可重复读（repeatable read）  | 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</br>当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的    |
| 串行化（serializable）      | 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。</br>当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行 |

```sql
create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```

|      事务A       |   事务B    |
| --------------- | --------- |
| 启动事务查询得到值1 | 启动事务    |
|                 | 查询得到值1 |
|                 | 将1改成2   |
| 查询得到值v1      |           |
|                 | 提交事务B   |
| 查询得到值v2      |           |
| 提交事务A         |           |
| 查询得到值v3      |           |


我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么。
+ 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
+ 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
+ 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
+ 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

# 隔离级别造成的问题
## 脏读
当数据库中一个事务A正在修改一个数据但是还未提交或者回滚，另一个事务B来读取了修改后的内容并且使用了，之后事务A提交了，此时就引起了脏读。
此情况仅会发生在：读未提交的的隔离级别
## 幻读
mysql基于readview查询不会出现幻读

首先，mysql 幻读并非是 "一个事务内进行两次相同操作居然得到了不一样的结果"，因为它根本不可能发生在使用了 read view / MVCC 的 RR 隔离级别下，这种幻读的定义更适合给 Oracle，Oracle 的事务隔离只有两级，RC 和 Serializable。然后还有很多人说不可重复读是针对某条记录的，幻读是针对记录集合的，这略微牵强....

这里给出mysql幻读的比较形象的场景：
```sql
T1 select * from users where id = 1;
T2：insert into `users`(`id`, `name`) values (1, 'big cat');
T1：insert into `users`(`id`, `name`) values (1, 'big cat');
```

T1 ：主事务，检测表中是否有 id 为 1 的记录，没有则插入，这是我们期望的正常业务逻辑。
T2 ：干扰事务，目的在于扰乱 T1 的正常的事务执行。

在 RR 隔离级别下，1、2 是会正常执行的，3 则会报错主键冲突，对于 T1 的业务来说是执行失败的，这里 T1 就是发生了幻读，因为T1读取的数据状态并不能支持他的下一步的业务，见鬼了一样。

# oracle与mysql默认等级不同
我们可以看到在不同的隔离级别下，数据库行为是有所不同的：
+ Oracle默认“读提交”
因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。
+ MySQL默认”可重复读“

# 设置隔离级别
sql
```sql
// 查看隔离级别
mysql> show variables like 'transaction_isolation';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.00 sec)

// 设置隔离级别
mysql> set global transaction isolation level repeatable read;
```

# 可重复读适用场景
假设你在管理一个个人银行账户表
一个表存了账户余额
一个表存了账单明细

到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。
你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。

这时候使用“可重复读”隔离级别就很方便。
事务启动时的视图可以认为是静态的，不受其他事务更新的影响。

# 实现方法
回滚段

# mysql关闭当前线程的事务
```sql
set autocommit=0
```

# 事务的坑
避免长事务