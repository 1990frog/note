[TOC]

# 三种常用数据结构
+ hash
+ array
+ tree

# hash
哈希表是一种以键值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。
哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。

不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。
处理这种情况的一种方法是，拉出一个链表。
```java
class Node{
    private key;
    private value;
    private Node next;
}
```

优势：新增速度快
劣势：因为不是有序的，所以哈希索引做区间查询的速度是很慢
所以，哈希表这种结构适用于只有`等值查询`的场景，比如`Memcached`及其他一些`NoSQL`引擎。

假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：
![](https://gitee.com/caijingquan/imagebed/raw/master/1602319701_20200403121445672_665289880.png)

# 有序数组
有序数组在等值查询和范围查询场景中的性能就都非常优秀
![](https://gitee.com/caijingquan/imagebed/raw/master/1602319703_20200403121506256_521533389.png)

这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的
这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))
同时很显然，这个索引结构支持范围查询
你要查身份证号在[ID_card_X, ID_card_Y]区间的 User
可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User）
然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。

如果仅仅看查询效率，有序数组就是最好的数据结构了。
但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。

所以，有序数组索引只适用于`静态存储`引擎，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。

# 二叉树
![](https://gitee.com/caijingquan/imagebed/raw/master/1602319704_20200403121533976_1793317052.png)

二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。

其原因是：
`索引不止存在内存中，还要写到磁盘上`
你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。
在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。
也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。
那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小

以 InnoDB 的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了

N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中
