[TOC]

主要看字段type，key

```
mysql> explain select * from product;
+----+-------------+---------+------------+------+---------------+------+---------+------+---------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra |
+----+-------------+---------+------------+------+---------------+------+---------+------+---------+----------+-------+
|  1 | SIMPLE      | product | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2533877 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+------+---------+------+---------+----------+-------+
```

# type 访问类型，关键列，索引使用情况
一般来说，好的sql查询至少达到range级别，最好能达到ref
| 值（性能至上而下排列）  |                                                                            含义                                                                            |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| system             | 这是const连接类型的一个特例，当查询的表只有一行时使用                                                                                                               |
| const              | 使用唯一索引或者主键，返回记录是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描                                                                      |
| eq_ref             | （join查询）出现在要连接过这个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref |
| ref                | 非唯一索引查找，返回匹配某个单独值的所有行                                                                                                                         |
| fulltext           | 全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引                                                                 |
| ref_or_null        | 与ref方法类似，只是增加了null值的比较。实际用的不多                                                                                                                |
| unique_subquery    | 用于where中的in形式子查询，子查询返回不重复值唯一值                                                                                                                |
| index_subquery     | 用于in形式只查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重                                                                              |
| range              | 索引范围扫描，常见于使用<,>,is null,between,in,like等运算符的查询中                                                                                                |
| index_merge        | 表示查询使用了两个以上的索引，最后取交集或者并集，常见and，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所有索引，性能可能大部分时间都不如range           |
| index              | 索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组查询                                                             |
| All                | 全表扫描数据文件，然后再在server层进行过滤返回复合要求的记录                                                                                                         |

# key 实际使用的索引
实际使用的索引，如果为NULL，则没有使用索引。
查询中如果使用了覆盖索引，则该索引仅出现在key列表中
`select_type`为`index_merge`时，这里可能出现两个以上的索引，其他的`select_type`这里只会出现一个

# id 越高越先执行
select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序
三种情况：
1. id相同：执行顺序由上至下
2. id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
3. id相同又不同（两种情况同时存在）：id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行
4. id列为null的就代表这是一个结果集，不需要使用它来进行查询

```sql
mysql> explain select a.name as student,c.name,b.name as tearcher from ganta a inner join ganta b on a.teacher = b.id left join gangs c on a.gang = c.code;
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+---------+----------+-------------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                | rows    | filtered | Extra       |
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+---------+----------+-------------+
|  1 | SIMPLE      | a     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL               | 2273209 |   100.00 | Using where |
|  1 | SIMPLE      | c     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | bigtable.a.gang    |       1 |   100.00 | NULL        |
|  1 | SIMPLE      | b     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | bigtable.a.teacher |       1 |   100.00 | NULL        |
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+---------+----------+-------------+
3 rows in set, 1 warning (0.00 sec)
```

# select_type 查询的类型
主要是用于区分普通查询、联合查询、子查询等复杂的查询
|       关键字       |                                        概念                                         | 例子 |
| ----------------- | ---------------------------------------------------------------------------------- | --- |
| simple             | 不包含只查询或是union操作的查询                                                          |     |
| primary            | 一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个 |     |
| subquery           | select列表中的子查询（from后的不算）                                                     |     |
| dependent subquery | 依赖外部结果的子查询（例如in后面的子查询）                                                 |     |
| union              | union操作的第二个或是之后的查询的值为union                                                |     |
| dependent union    | 当union作为子查询时，第二或是第二个之后的查询的select_type值                                 |     |
| union result       | union产生的结果集                                                                     |     |
| derived            | 出现在from子句中的子查询                                                               |     |

# table 表名
+ 显示的查询表名
+ 如果查询使用了别名，那么这里显示的是别名
+ 如果不涉及对数据表的操作，那么这显示为null
+ 如果显示为尖括号括起来的<derived N>就表示这个是临时表
+ 如果显示`<unionM,N>`表示为id由m，n查询union产生的结果集
+ 如果显示`<subquery N>`

# partitions 分区表
+ 对于分区表，显示查询的分区id
+ 对分区表显示null

# possible_keys 查询字段上存在的索引，不一定被使用
查询涉及到的字段上存在索引，则该索引将被列出，但不一定被查询实际使用

# key_len
表示索引中使用的字节数，查询中使用的索引的长度（最大可能长度），并非实际使用长度，理论上长度越短越好。key_len是根据表定义计算而得的，不是通过表内检索出的

+ 用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去
# ref
显示索引的那一列被使用了，如果可能，是一个常量const。

如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划智力会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列放生了内部隐式转换，这里可能显示为func
# rows
根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数

+ 根据统计信息预估的扫描行数
# filtered
# Extra
不适合在其他字段中显示，但是十分重要的额外信息

+ distinct：在select部分使用了distinct关键字
+ no tables used：不带from字句的查询或者From dual查询
+ using filesort：排序时无法使用索引时，就会出现这个。常见于order by和group by语句中
+ using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据
+ using intersect：表示使用and各个索引的条件时，该信息表示是从处理结果获取交集
+ using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取交集
+ using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤

|             值              |                           含义                           |
| --------------------------- | ------------------------------------------------------- |
| distinct                    | 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作       |
| not exists                  | 使用not exists来优化查询                                    |
| using filesort              | 排序时无法使用索引时，就会出现这个。常见于order by和group by语句中 |
| using index                 | 使用了覆盖索引进行查询                                       |
| using temporary              | mysql需要使用临时表来处理查询，常见于排序，子查询，和分组查询       |
| using where                 | 需要在mysql服务器层使用where条件来过滤数据                     |
| select tables optimized away | 直接通过索引来获得数据，不用访问表                             |



# 实战
```
mysql> select count(id) from ganta;
+-----------+
| count(id) |
+-----------+
|   2601923 |
+-----------+
1 row in set (0.09 sec)

mysql> select count(name) from ganta;
+-------------+
| count(name) |
+-------------+
|     2601923 |
+-------------+
1 row in set (0.40 sec)

mysql> explain select count(id) from ganta;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows    | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+
|  1 | SIMPLE      | ganta | NULL       | index | NULL          | PRIMARY | 4       | NULL | 2273209 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select count(name) from ganta;
+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------+
|  1 | SIMPLE      | ganta | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2273209 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------+
1 row in set, 1 warning (0.00 sec)

```
