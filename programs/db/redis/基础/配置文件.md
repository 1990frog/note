[TOC]

习惯在redis目录下data/config/redis-{port}.conf 存放我们的config

# 例子
```
# Redis configuration file example.
# Redis配置文件示例。
#
# Note that in order to read the configuration file, Redis must be
# started with the file path as first argument:
# 注意，为了读取配置文件，Redis必须是从文件路径开始作为第一个参数：
#
# ./redis-server /path/to/redis.conf


# Note on units: when memory size is needed, it is possible to specify
# it in the usual form of 1k 5GB 4M and so forth:
# 注意单元：当需要内存大小时，可以指定它通常是1k、5GB、4M，等等：
#
# 1k => 1000 bytes
# 1kb => 1024 bytes
# 1m => 1000000 bytes
# 1mb => 1024*1024 bytes
# 1g => 1000000000 bytes
# 1gb => 1024*1024*1024 bytes
#
# units are case insensitive so 1GB 1Gb 1gB are all the same.
# 单位是大小写不敏感的，所以1GB、1Gb、1gB都是一样的。
```

# include
```
################################## INCLUDES 包含配置 ###################################


# Include one or more other config files here.  This is useful if you
# have a standard template that goes to all Redis servers but also need
# to customize a few per-server settings.  Include files can include
# other files, so use this wisely.
# 在这里包含一个或多个其他配置文件。如果您有一个标准的模板，它可以访问所有Redis服务器，但是也需要定制每个服务器的设置，这是非常有用的。
# 包含文件可以包含其他文件，所以要明智地使用它。
#
# Notice option "include" won't be rewritten by command "CONFIG REWRITE"
# from admin or Redis Sentinel. Since Redis always uses the last processed
# line as value of a configuration directive, you'd better put includes
# at the beginning of this file to avoid overwriting config change at runtime.
# 注意选项“include”不会通过命令“CONFIG REWRITE”从admin或Redis Sentinel（redis 哨兵）重写。
# 由于Redis总是使用最后一条处理线作为配置指令的值，所以最好在这个文件的开头加上包含，以避免在运行时重写配置更改。
#
# If instead you are interested in using includes to override configuration
# options, it is better to use include as the last line.
# 如果您感兴趣的是使用include来覆盖配置选项，那么最好使用include作为最后一行。
#
# include /path/to/local.conf
# include /path/to/other.conf
```

# moudle
```
################################## MODULES 模块配置 #####################################


# Load modules at startup. If the server is not able to load modules
# it will abort. It is possible to use multiple loadmodule directives.
# 在启动时加载模块。如果服务器不能加载模块，它就会中止。可以使用多个loadmodule指令。
#
# loadmodule /path/to/my_module.so
# loadmodule /path/to/other_module.so
```

# RDB
```config
################################ SNAPSHOTTING 快照配置 ################################
#
# Save the DB on disk:
# 将数据保存在磁盘上：
#
#   save <seconds> <changes>
#
#   Will save the DB if both the given number of seconds and the given
#   如果给定的秒数和给定的秒数，就会保存DB（针对参数seconds）
#   number of write operations against the DB occurred.
#   发生了针对DB的写操作的数量。（针对参数changes）
#
#   In the example below the behaviour will be to save:
#   在下面的例子中，行为将是保存：
#   after 900 sec (15 min) if at least 1 key changed
#   900秒内至少有1次写入
#   after 300 sec (5 min) if at least 10 keys changed
#   300秒内至少有10次写入
#   after 60 sec if at least 10000 keys changed
#   60秒内至少有10000次写入
#
#   Note: you can disable saving completely by commenting out all "save" lines.
#   注意：你可以通过注释掉所有的“保存”行来完全禁用保存。
#
#   It is also possible to remove all the previously configured save
#   也可以删除先前配置的所有save
#   points by adding a save directive with a single empty string argument
#   通过添加一个带有空字符串参数的save指令
#   like in the following example:
#   如下面的例子：
#
#   save ""


save 900 1
save 300 10
save 60 10000
```
# AOF
```config
############################## APPEND ONLY MODE 只附加模式(AOF) ###############################


# By default Redis asynchronously dumps the dataset on disk. This mode is
# good enough in many applications, but an issue with the Redis process or
# a power outage may result into a few minutes of writes lost (depending on
# the configured save points).
# 默认情况下，Redis会异步地将数据集转储到磁盘上。在许多应用程序中，这种模式已经足够好了，但是Redis进程或断电的问题可能会导致几分钟的写入丢失（取决于配置的保存点）。
#
# The Append Only File is an alternative persistence mode that provides
# much better durability. For instance using the default data fsync policy
# (see later in the config file) Redis can lose just one second of writes in a
# dramatic event like a server power outage, or a single write if something
# wrong with the Redis process itself happens, but the operating system is
# still running correctly.
# Append Only File是一种可替代的持久性模式，它提供了更好的持久性。
# 例如使用默认数据fsync策略配置文件中(见后)复述,可以失去只是一秒的写在一个戏剧性的事件像一个服务器断电,或一个写如果复述过程本身出了问题,但正确操作系统仍在运行。
#
# AOF and RDB persistence can be enabled at the same time without problems.
# If the AOF is enabled on startup Redis will load the AOF, that is the file
# with the better durability guarantees.
# AOF和RDB持久性可以同时启用，而不会出现问题。如果在启动时启用了AOF，Redis将加载AOF，那就是具有更好的持久性保证的文件。
#
# Please check http://redis.io/topics/persistence for more information.
# 请检查 http://redis.io/topics/persistence 获取久性的更多信息。


appendonly no


# The name of the append only file (default: "appendonly.aof")
# 只追加文件的名称（默认："appendonly.aof"）


appendfilename "appendonly.aof"


# The fsync() call tells the Operating System to actually write data on disk
# instead of waiting for more data in the output buffer. Some OS will really flush
# data on disk, some other OS will just try to do it ASAP.
# fsync()调用告诉操作系统在磁盘上实际写入数据，而不是在输出缓冲器中等待更多的数据。一些操作系统将真正地刷新磁盘上的数据，其他一些操作系统将会尽快地完成它。
#
# Redis supports three different modes:
# Redis支持三种不同的模式：
#
# no: don't fsync, just let the OS flush the data when it wants. Faster.
#     不要fsync，只要让操作系统在需要的时候刷新数据。得更快。
# always: fsync after every write to the append only log. Slow, Safest.
#         始终：每次写入追加日志后。
# everysec: fsync only one time every second. Compromise.
#           缓慢的,安全的。每秒钟只做一次。妥协。
#
# The default is "everysec", as that's usually the right compromise between
# speed and data safety. It's up to you to understand if you can relax this to
# "no" that will let the operating system flush the output buffer when
# it wants, for better performances (but if you can live with the idea of
# some data loss consider the default persistence mode that's snapshotting),
# or on the contrary, use "always" that's very slow but a bit safer than
# everysec.
# 默认情况下是“everysec”，因为这通常是速度和数据安全之间的正确折衷。
# 由你理解如果你能放松这个“no”字,让操作系统刷新输出缓冲区时,为了更好的表现(但是如果你可以忍受一些数据丢失的想法考虑默认快照的持久性模式),或相反,使用“always”非常缓慢但比everysec更安全一点。
#
# More details please check the following article:
# 更多详情请查看以下文章：
# http://antirez.com/post/redis-persistence-demystified.html
#
# If unsure, use "everysec".
# 如果不确定,使用“everysec”。


# appendfsync always
appendfsync everysec
# appendfsync no


# When the AOF fsync policy is set to always or everysec, and a background
# saving process (a background save or AOF log background rewriting) is
# performing a lot of I/O against the disk, in some Linux configurations
# Redis may block too long on the fsync() call. Note that there is no fix for
# this currently, as even performing fsync in a different thread will block
# our synchronous write(2) call.
# 当AOF fsync策略被设置为总是或everysec时，后台保存过程（后台保存或日志后台重写）在磁盘上执行大量的输入输出，在一些Linux配置中，Redis可能会在fsync()调用上阻塞太长时间。
# 注意，目前还没有解决这个问题的方法，因为即使在不同的线程中执行fsync也会阻塞我们的同步写入（2）调用。
#
# In order to mitigate this problem it's possible to use the following option
# that will prevent fsync() from being called in the main process while a
# BGSAVE or BGREWRITEAOF is in progress.
# 为了减轻这个问题，可以使用以下选项来防止fsyn()在主进程中被调用，而BGSAVE或BGREWRITEAOF正在进行中。
#
# This means that while another child is saving, the durability of Redis is
# the same as "appendfsync none". In practical terms, this means that it is
# possible to lose up to 30 seconds of log in the worst scenario (with the
# default Linux settings).
# 这意味着，当另一个子进程在保存的时候，Redis的耐用性和“appendfsync none”是一样的。在实际操作中，这意味着在最坏的情况下（使用默认的Linux设置）可能会损失30秒的日志。
#
# If you have latency problems turn this to "yes". Otherwise leave it as
# "no" that is the safest pick from the point of view of durability.
# 如果你有延迟问题，就把这个问题变成“yes”。
# 否则就把它当作“no”，从耐用性的角度来看，这是最安全的选择。


no-appendfsync-on-rewrite no


# Automatic rewrite of the append only file.
# Redis is able to automatically rewrite the log file implicitly calling
# BGREWRITEAOF when the AOF log size grows by the specified percentage.
# 自动重写附加文件。Redis能够自动重写日志文件，当AOF日志大小以指定的百分比增长时，它会隐式地调用BGREWRITEAOF。
#
# This is how it works: Redis remembers the size of the AOF file after the
# latest rewrite (if no rewrite has happened since the restart, the size of
# the AOF at startup is used).
# 这就是它的工作原理：Redis在最新的重写之后记住了AOF文件的大小（如果重新启动后没有重写，那么在启动时就会使用AOF的大小）。
#
# This base size is compared to the current size. If the current size is
# bigger than the specified percentage, the rewrite is triggered. Also
# you need to specify a minimal size for the AOF file to be rewritten, this
# is useful to avoid rewriting the AOF file even if the percentage increase
# is reached but it is still pretty small.
# 这个基本尺寸与当前的大小比较。如果当前的大小大于指定的百分比，则重写被触发。
# 此外，您还需要为将要重写的AOF文件指定最小的大小，这对于避免重写AOF文件是很有用的，即使百分比增加了，但它仍然很小。
#
# Specify a percentage of zero in order to disable the automatic AOF
# rewrite feature.
# 指定0%的百分比来禁用自动重写功能。


auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb


# An AOF file may be found to be truncated at the end during the Redis
# startup process, when the AOF data gets loaded back into memory.
# This may happen when the system where Redis is running
# crashes, especially when an ext4 filesystem is mounted without the
# data=ordered option (however this can't happen when Redis itself
# crashes or aborts but the operating system still works correctly).
# 在Redis启动过程中，当AOF数据被加载回内存时，可能会发现一个AOF文件会被截断。
# 当Redis正在运行崩溃的系统时，这可能会发生，特别是当一个ext4文件系统在没有data=ordered选项的情况下安装时（但是当Redis本身崩溃或中止时，这是不可能发生的，但是操作系统仍然正常工作）。
#
# Redis can either exit with an error when this happens, or load as much
# data as possible (the default now) and start if the AOF file is found
# to be truncated at the end. The following option controls this behavior.
# 当发生这种情况时，Redis可以以错误退出，或者加载尽可能多的数据（默认情况下），并在最终发现AOF文件被截断时开始。
# 下面的选项控制这种行为。
#
# If aof-load-truncated is set to yes, a truncated AOF file is loaded and
# the Redis server starts emitting a log to inform the user of the event.
# Otherwise if the option is set to no, the server aborts with an error
# and refuses to start. When the option is set to no, the user requires
# to fix the AOF file using the "redis-check-aof" utility before to restart
# the server.
# 如果被截断的截断被设置为yes，则加载一个截断的AOF文件，Redis服务器开始发出一个日志来通知用户事件。
# 否则，如果选项被设置为no，服务器就会出现错误并拒绝启动。
# 当选项被设置为no时，用户需要在重启服务器之前使用“redis-核对”实用程序来修复AOF文件。
#
# Note that if the AOF file will be found to be corrupted in the middle
# the server will still exit with an error. This option only applies when
# Redis will try to read more data from the AOF file but not enough bytes
# will be found.
# 注意，如果AOF文件在中间被发现损坏，服务器仍然会出现错误。
# 只有当Redis试图从AOF文件中读取更多数据时，才会使用该选项，但不会找到足够的字节。
aof-load-truncated yes


# When rewriting the AOF file, Redis is able to use an RDB preamble in the
# AOF file for faster rewrites and recoveries. When this option is turned
# on the rewritten AOF file is composed of two different stanzas:
# 在重写AOF文件时，Redis能够在AOF文件中使用RDB序言，以获得更快的重写和恢复。
# 当这个选项被打开时，重写的AOF文件由两个不同的小节组成：
#
#   [RDB file][AOF tail]
#
# When loading Redis recognizes that the AOF file starts with the "REDIS"
# string and loads the prefixed RDB file, and continues loading the AOF
# tail.
# 加载Redis时，确认AOF文件以“Redis”字符串开头，并加载预固定的RDB文件，并继续加载AOF tail。
#
# This is currently turned off by default in order to avoid the surprise
# of a format change, but will at some point be used as the default.
# 这在默认情况下是关闭的，以避免格式更改的意外，但在某些时候会被用作默认值。
aof-use-rdb-preamble no
```

# NetWork
```
################################## NETWORK 网络配置 #####################################


# By default, if no "bind" configuration directive is specified, Redis listens
# for connections from all the network interfaces available on the server.
# It is possible to listen to just one or multiple selected interfaces using
# the "bind" configuration directive, followed by one or more IP addresses.
# 默认情况下，如果没有指定“bind”配置指令，Redis会监听用于从服务器上可用的所有网络接口的连接。
# 使用“bind”配置指令监听一个或多个选定的接口是可能的，然后是一个或多个IP地址。
#
# Examples:
# 例如：
#
# bind 192.168.1.100 10.0.0.1
# bind 127.0.0.1 ::1
#
# ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the
# internet, binding to all the interfaces is dangerous and will expose the
# instance to everybody on the internet. So by default we uncomment the
# following bind directive, that will force Redis to listen only into
# the IPv4 lookback interface address (this means Redis will be able to
# accept connections only from clients running into the same computer it
# is running).
# 警告如果运行redis的计算机直接暴露在因特网上，绑定到所有的接口是危险的，并且会将实例暴露给internet上的每个人。
# 因此，在默认情况下，我们取消了以下绑定指令，这将迫使Redis只监听IPv4 lookback接口地址（这意味着Redis将只能接受来自运行到其正在运行的同一台计算机的客户端的连接）。
#
# IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES
# JUST COMMENT THE FOLLOWING LINE.
# 如果您确定希望您的实例侦听所有接口，请注释以下一行。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
bind 172.0.0.1


# Protected mode is a layer of security protection, in order to avoid that
# Redis instances left open on the internet are accessed and exploited.
# 保护模式是一层安全保护，以避免在internet上打开的Redis实例被访问和利用。
# 
# When protected mode is on and if:
# 当保护模式开启时，如果：
#
# 1) The server is not binding explicitly to a set of addresses using the
#    "bind" directive.
#    服务器不使用“bind”指令显式地绑定到一组地址。
# 2) No password is configured.
#    没有密码配置。
#
# The server only accepts connections from clients connecting from the
# IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain
# sockets.
# 服务器只接受来自IPv4和IPv6环路的客户端的连接，127.0.0.1 和 ::1，以及Unix域套接字。
#
# By default protected mode is enabled. You should disable it only if
# you are sure you want clients from other hosts to connect to Redis
# even if no authentication is configured, nor a specific set of interfaces
# are explicitly listed using the "bind" directive.
# 默认保护模式是启用的。只有当您确信您希望其他主机的客户端连接到Redis时，您才应该禁用它，即使没有配置身份验证，也不需要使用“bind”指令显式地列出特定的接口集。
protected-mode yes


# Accept connections on the specified port, default is 6379 (IANA #815344).
# If port 0 is specified Redis will not listen on a TCP socket.
# 接受指定端口上的连接，默认为6379（IANA 815344）。如果指定端口0，Redis将不会监听TCP套接字。
port 6379


# TCP listen() backlog.
# TCP listen() 积压
#
# In high requests-per-second environments you need an high backlog in order
# to avoid slow clients connections issues. Note that the Linux kernel
# will silently truncate it to the value of /proc/sys/net/core/somaxconn so
# make sure to raise both the value of somaxconn and tcp_max_syn_backlog
# in order to get the desired effect.
# 在 高请求/秒 的环境中，为了避免客户端连接问题的缓慢，您需要大量的积压。
# 请注意，Linux内核将会悄悄地将其截断为/proc/sy/net/core/somaxconn的值，因此要确保提高somaxconn和tcpmaxsynbacklog的值，以获得预期的效果。
tcp-backlog 511


# Unix socket.
#
# Specify the path for the Unix socket that will be used to listen for
# incoming connections. There is no default, so Redis will not listen
# on a unix socket when not specified.
# 指定用于侦听传入连接的Unix socket的路径。没有默认值，所以Redis在没有指定的情况下不会监听Unix socket。
#
# unixsocket /tmp/redis.sock
# unixsocketperm 700


# Close the connection after a client is idle for N seconds (0 to disable)
# 在客户端闲置N秒后关闭连接（0 禁用）
timeout 0


# TCP keepalive.
#
# If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence
# of communication. This is useful for two reasons:
# 如果非零，在没有通信的情况下使用sokeepalive向客户发送TCP ack。这有两个原因：
#
# 1) Detect dead peers.
#    发现死去的同伴。
# 2) Take the connection alive from the point of view of network
#    equipment in the middle.
#    从中间的网络设备的角度来看待连接。
#
# On Linux, the specified value (in seconds) is the period used to send ACKs.
# Note that to close the connection the double of the time is needed.
# On other kernels the period depends on the kernel configuration.
# 在Linux上，指定的值（以秒为单位）是用来发送ack的时间。
# 注意，要关闭连接，需要的时间是双倍的。
# 在其他内核上，周期取决于内核配置。
#
# A reasonable value for this option is 300 seconds, which is the new
# Redis default starting with Redis 3.2.1.
# 这个选项的一个合理值是300秒，这是从Redis 3.2.1开始的新Redis默认值。
tcp-keepalive 300
```

# General
```
################################# GENERAL 常规配置 #####################################


# By default Redis does not run as a daemon. Use 'yes' if you need it.
# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
# 默认情况下，Redis不作为守护进程运行。如果你需要，请用“是”。
# 请注意，如果开启，Redis将在/var/run/redis.pid中编写一个pid文件。
daemonize no


# If you run Redis from upstart or systemd, Redis can interact with your
# supervision tree. Options:
# 如果您从upstart或systemd中运行Redis，Redis可以与您的监督树交互。选项:
# 
#   supervised no      - no supervision interaction
#                        没有监督互动
#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode
#                        通过将Redis放入SIGSTOP模式
#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET
#                        通过写入就绪=1到$notifysocket的信号系统
#   supervised auto    - detect upstart or systemd method based on
#                        UPSTART_JOB or NOTIFY_SOCKET environment variables
#                        根据upstartjob或notifysocket环境变量检测upstart或systemd方法
# Note: these supervision methods only signal "process is ready."
#       They do not enable continuous liveness pings back to your supervisor.
# 注意：这些监督方法只表示“进程已经准备好了”。
#       他们不会让你的上司不断地向你的上司发信号。
supervised no


# If a pid file is specified, Redis writes it where specified at startup
# and removes it at exit.
# 如果指定了pid文件，Redis在启动时指定它，并在出口处删除它。
#
# When the server runs non daemonized, no pid file is created if none is
# specified in the configuration. When the server is daemonized, the pid file
# is used even if not specified, defaulting to "/var/run/redis.pid".
# 当服务器运行非监控时，如果在配置中没有指定任何pid文件，则不会创建pid文件。
# 当服务器被启用时，即使没有指定pid文件，也会使用它，默认为“/var/run/redis.pid”。
#
# Creating a pid file is best effort: if Redis is not able to create it
# nothing bad happens, the server will start and run normally.
# 创建一个pid文件是最好的工作：如果Redis不能创建它，那么就会发生不好的事情，服务器将正常启动和运行。
pidfile /var/run/redis_6379.pid


# Specify the server verbosity level.
# 指定服务器的冗长级别。
# This can be one of:
# 这可以是：
# debug (a lot of information, useful for development/testing)
#        大量的信息，对于开发/测试很有用
# verbose (many rarely useful info, but not a mess like the debug level)
#          许多很少有用的信息，但不是像调试级别那样的混乱
# notice (moderately verbose, what you want in production probably)
#         稍微啰嗦，你在生产中想要什么
# warning (only very important / critical messages are logged)
#          只记录非常重要的/关键的消息
loglevel notice


# Specify the log file name. Also the empty string can be used to force
# Redis to log on the standard output. Note that if you use standard
# output for logging but daemonize, logs will be sent to /dev/null
# 指定日志文件名。
# 此外，空字符串可以用来强制Redis登录标准输出。
# 注意，如果您使用标准输出来进行日志记录，但是将日志发送到/dev/null，那么日志将被发送到/dev/null
logfile ""


# To enable logging to the system logger, just set 'syslog-enabled' to yes,
# and optionally update the other syslog parameters to suit your needs.
# 为了使日志记录到系统记录器，只需将“syslog-enabled”设置为yes，并可选择性地更新其他syslog参数以满足您的需要。
# syslog-enabled no


# Specify the syslog identity.
# 指定syslog的身份。
# syslog-ident redis


# Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.
# 指定syslog工具。必须是用户或本地-local7之间。
# syslog-facility local0


# Set the number of databases. The default database is DB 0, you can select
# a different one on a per-connection basis using SELECT <dbid> where
# dbid is a number between 0 and 'databases'-1
# 设置数据库的数量。
# 默认数据库是DB 0，您可以在每个连接的基础上选择一个不同的数据库，其中dbid是一个介于0和“数据库”-1之间的数字
databases 16


# By default Redis shows an ASCII art logo only when started to log to the
# standard output and if the standard output is a TTY. Basically this means
# that normally a logo is displayed only in interactive sessions.
# 默认情况下，Redis只在开始记录标准输出时显示一个ASCII艺术徽标，如果标准输出是一个TTY。
# 基本上，这意味着通常只有在交互式会话中才会显示徽标。
#
# However it is possible to force the pre-4.0 behavior and always show a
# ASCII art logo in startup logs by setting the following option to yes.
# 然而，在启动日志中，通过设置以下选项，可以强制执行pre4.0行为，并在启动日志中显示ASCII艺术徽标。
always-show-logo yes





# By default Redis will stop accepting writes if RDB snapshots are enabled
# 默认情况下，如果启用RDB快照，Redis将停止接受写入
# (at least one save point) and the latest background save failed.
# （至少一个保存点）和最新的后台保存失败。
# This will make the user aware (in a hard way) that data is not persisting
# on disk properly, otherwise chances are that no one will notice and some
# disaster will happen.
# 这将使用户意识到（以一种困难的方式）数据不会正确地持久化到磁盘上，否则很可能没有人会注意到，一些灾难将会发生。
#
# If the background saving process will start working again Redis will
# automatically allow writes again.
# 如果后台保存过程将重新开始工作，Redis将自动允许重写。
#
# However if you have setup your proper monitoring of the Redis server
# and persistence, you may want to disable this feature so that Redis will
# continue to work as usual even if there are problems with disk,
# permissions, and so forth.
# 但是，如果您已经对Redis服务器和持久性进行了适当的监测，那么您可能想要禁用这个特性，这样即使在磁盘、许可权等问题上存在问题，Redis也会继续正常工作。
stop-writes-on-bgsave-error yes


# Compress string objects using LZF when dump .rdb databases?
# For default that's set to 'yes' as it's almost always a win.
# If you want to save some CPU in the saving child set it to 'no' but
# the dataset will likely be bigger if you have compressible values or keys.
# 在转储.rdb数据库时使用LZF压缩字符串对象？
# 默认情况下，这是“是”，因为它几乎总是一场胜利。如果你想在保存的孩子中保存一些CPU，将其设置为“no”，但是如果你有可压缩的值或键，那么数据集可能会大。

rdbcompression yes


# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
# This makes the format more resistant to corruption but there is a performance
# hit to pay (around 10%) when saving and loading RDB files, so you can disable it
# for maximum performances.
# 自从RDB版本5以来，CRC64校验和被放置在文件的末尾。
# 这使得这种格式对腐败更有抵抗力，但是在保存和加载RDB文件时，会有一个性能损失（大约10%），所以您可以禁用它以获得最大的性能。
#
# RDB files created with checksum disabled have a checksum of zero that will
# tell the loading code to skip the check.
# 用校验和禁用的RDB文件有一个零校验和，它会告诉加载代码跳过检查。
rdbchecksum yes


# The filename where to dump the DB
# 要转储DB的文件名
dbfilename dump.rdb


# The working directory.
# 工作目录。
#
# The DB will be written inside this directory, with the filename specified
# above using the 'dbfilename' configuration directive.
# DB将被写入这个目录中，使用“dbfilename”配置指令指定上面指定的文件名。
#
# The Append Only File will also be created inside this directory.
# 附加的文件也将在这个目录中创建。
#
# Note that you must specify a directory here, not a file name.
# 注意，您必须在这里指定一个目录，而不是一个文件名。
dir ./
```

# 主从复制
```
################################# REPLICATION 复制设置（主从） #################################


# Master-Slave replication. Use slaveof to make a Redis instance a copy of
# another Redis server. A few things to understand ASAP about Redis replication.
# 主从复制。使用slaveof来做一个Redis实例一个Redis服务器的副本。
# 关于Redis的复制，需要了解一些事情。
#
# 1) Redis replication is asynchronous, but you can configure a master to
#    stop accepting writes if it appears to be not connected with at least
#    a given number of slaves.
#    Redis复制是异步的，但是您可以配置一个主服务，如果它看起来与至少给定数量的从服务没有连接，就可以停止接受写操作。
# 2) Redis slaves are able to perform a partial resynchronization with the
#    master if the replication link is lost for a relatively small amount of
#    time. You may want to configure the replication backlog size (see the next
#    sections of this file) with a sensible value depending on your needs.
#    如果复制链接在相对较小的时间内丢失，那么Redis的从服务就可以执行部分重新同步。
#    您可能希望配置复制待办事项列表大小（请参阅该文件的下一部分），并根据您的需要确定一个合理的值。
#    
# 3) Replication is automatic and does not need user intervention. After a
#    network partition slaves automatically try to reconnect to masters
#    and resynchronize with them.
#    复制是自动的，不需要用户干预。在网络分区之后，从服务会自动尝试重新连接到主服务并与他们重新同步。
#
# slaveof <masterip> <masterport>
# slaveof 主服务ip 主服务端口


# If the master is password protected (using the "requirepass" configuration
# directive below) it is possible to tell the slave to authenticate before
# starting the replication synchronization process, otherwise the master will
# refuse the slave request.
# 如果主密码保护（使用下面的“requirepass”配置指令），在启动复制同步过程之前，可以告诉从服务进行身份验证，否则主服务将拒绝从服务请求。
#
# masterauth <master-password>
# masterauth 主服务密码


# When a slave loses its connection with the master, or when the replication
# is still in progress, the slave can act in two different ways:
# 当一个从服务失去与主服务的联系，或者当复制还在进行的时候，从服务可以以两种不同的方式行动：
#
# 1) if slave-serve-stale-data is set to 'yes' (the default) the slave will
#    still reply to client requests, possibly with out of date data, or the
#    data set may just be empty if this is the first synchronization.
#    如果将slave-serve-stale-data设置为“yes”（默认值），则从服务仍然会回复客户端请求，可能是使用过期数据，或者如果这是第一次同步，数据集可能是空的。
#
# 2) if slave-serve-stale-data is set to 'no' the slave will reply with
#    an error "SYNC with master in progress" to all the kind of commands
#    but to INFO and SLAVEOF.
#    如果slave-serve-stale-data被设置为“no”，那么从服务将会以“与主同步”的错误来回答所有的命令，而不是INFO and SLAVEOF。
#    
slave-serve-stale-data yes


# You can configure a slave instance to accept writes or not. Writing against
# a slave instance may be useful to store some ephemeral data (because data
# written on a slave will be easily deleted after resync with the master) but
# may also cause problems if clients are writing to it because of a
# misconfiguration.
# 您可以配置一个从服务实例来接受写操作。
# 针对从属实例的写作可能有助于存储一些短暂的数据（因为在与主服务器重新同步之后，在从服务上编写的数据很容易被删除），但如果客户端由于配置错误而对其进行写入，也可能会导致问题。
#
# Since Redis 2.6 by default slaves are read-only.
# 因为从服务默认是只读的。
#
# Note: read only slaves are not designed to be exposed to untrusted clients
# on the internet. It's just a protection layer against misuse of the instance.
# Still a read only slave exports by default all the administrative commands
# such as CONFIG, DEBUG, and so forth. To a limited extent you can improve
# security of read only slaves using 'rename-command' to shadow all the
# administrative / dangerous commands.
# 注意：只读从服务并不是被设计成在互联网上暴露给不受信任的客户端。它只是防止误用实例的保护层。
# 在默认情况下，仍然是只读的从服务导出，包括CONFIG、DEBUG等所有管理命令。
# 在有限的范围内，您可以使用“rename-command”来提高只读从服务的安全性，从而使所有的管理/危险命令都受到影响。
slave-read-only yes


# Replication SYNC strategy: disk or socket.
# 复制同步策略：磁盘或socket。
#
# -------------------------------------------------------
# WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY
# -------------------------------------------------------
# 警告：无磁盘复制目前是实验性的
#
# New slaves and reconnecting slaves that are not able to continue the replication
# process just receiving differences, need to do what is called a "full
# synchronization". An RDB file is transmitted from the master to the slaves.
# The transmission can happen in two different ways:
# 新的从服务和重新连接的从服务不能继续复制过程仅仅是接受差异，需要做所谓的“完全同步”。一个RDB文件从主服务器传输到从服务。
# 这种传播有两种不同的方式：
#
# 1) Disk-backed: The Redis master creates a new process that writes the RDB
#                 file on disk. Later the file is transferred by the parent
#                 process to the slaves incrementally.
#                 Redis的主服务创建了一个新的进程，在磁盘上写入RDB文件。稍后，该文件由父进程以增量方式传递给从服务。
# 2) Diskless: The Redis master creates a new process that directly writes the
#              RDB file to slave sockets, without touching the disk at all.
#              Redis的主服务创建了一个新的进程，它直接将RDB文件写到从服务socket，而不需要触碰磁盘。
#
# With disk-backed replication, while the RDB file is generated, more slaves
# can be queued and served with the RDB file as soon as the current child producing
# the RDB file finishes its work. With diskless replication instead once
# the transfer starts, new slaves arriving will be queued and a new transfer
# will start when the current one terminates.
# 有了磁盘支持的复制，当RDB文件生成时，就会有更多的从服务在当前的RDB文件完成工作后立即排队并使用RDB文件。
# 当传输开始时，没有磁盘的复制，新的从服务将会排队，当当前的传输结束时，新的传输将开始。
#
# When diskless replication is used, the master waits a configurable amount of
# time (in seconds) before starting the transfer in the hope that multiple slaves
# will arrive and the transfer can be parallelized.
# 当使用无磁盘复制时，主服务器在开始传输之前等待一个可配置的时间（以秒为单位），希望多个从服务能够到达，并且传输可以并行化。
#
# With slow disks and fast (large bandwidth) networks, diskless replication
# works better.
# 使用慢速磁盘和快速（大带宽）网络，无磁盘复制效果更好。
repl-diskless-sync no


# When diskless replication is enabled, it is possible to configure the delay
# the server waits in order to spawn the child that transfers the RDB via socket
# to the slaves.
# 当启用无磁盘复制时，可以配置服务器等待的延迟，以便派生出将RDB通过套接字传输到从服务的子节点。
#
# This is important since once the transfer starts, it is not possible to serve
# new slaves arriving, that will be queued for the next RDB transfer, so the server
# waits a delay in order to let more slaves arrive.
# 这是很重要的，因为一旦传输开始，就不可能为新到的从服务提供服务，这将会排队等待下一个RDB传输，所以服务器等待一个延迟，以便让更多的从服务到达。
#
# The delay is specified in seconds, and by default is 5 seconds. To disable
# it entirely just set it to 0 seconds and the transfer will start ASAP.
# 延迟是在几秒内指定的，默认情况下是5秒。要完全禁用它，只需将它设置为0秒，然后传输就会尽快开始。
repl-diskless-sync-delay 5


# Slaves send PINGs to server in a predefined interval. It's possible to change
# this interval with the repl_ping_slave_period option. The default value is 10
# seconds.
# 从服务在一个预定义的时间间隔内向服务器发送ping信号。可以用replpingslave句号选项来改变这个区间。默认值是10秒。
#
# repl-ping-slave-period 10


# The following option sets the replication timeout for:
# 下面的选项用来设置复制超时：
#
# 1) Bulk transfer I/O during SYNC, from the point of view of slave.
#    从从服务的角度看，在同步过程中，批量传输的输入输出。
# 2) Master timeout from the point of view of slaves (data, pings).
#    从从服务的角度（数据，ping信号）中掌握超时。
# 3) Slave timeout from the point of view of masters (REPLCONF ACK pings).
#    从主服务（REPLCONF ACK ping包）的角度来看，从服务器超时。
#
# It is important to make sure that this value is greater than the value
# specified for repl-ping-slave-period otherwise a timeout will be detected
# every time there is low traffic between the master and the slave.
# 重要的是要确保这个值大于为repl-ping期间指定的值，否则每次在主服务器和从服务之间的流量都很低时，就会检测到超时。
#
# repl-timeout 60


# Disable TCP_NODELAY on the slave socket after SYNC?
# 在同步后禁用tcpno延时？
#
# If you select "yes" Redis will use a smaller number of TCP packets and
# less bandwidth to send data to slaves. But this can add a delay for
# the data to appear on the slave side, up to 40 milliseconds with
# Linux kernels using a default configuration.
# 如果您选择“yes”，Redis将使用较少的TCP数据包和更少的带宽来将数据发送给从服务。但是这可能会增加数据在从服务端出现的延迟，使用默认配置的Linux内核可以使用40毫秒。
#
# If you select "no" the delay for data to appear on the slave side will
# be reduced but more bandwidth will be used for replication.
# 如果您选择“no”，那么在从服务端出现的数据延迟将会减少，但是更多的带宽将被用于复制。
#
# By default we optimize for low latency, but in very high traffic conditions
# or when the master and slaves are many hops away, turning this to "yes" may
# be a good idea.
# 在默认情况下，我们优化了低延迟，但是在非常高的交通条件下，或者当主服务和从服务有很多跳的时候，把这个变成“是”可能是个好主意。
repl-disable-tcp-nodelay no


# Set the replication backlog size. The backlog is a buffer that accumulates
# slave data when slaves are disconnected for some time, so that when a slave
# wants to reconnect again, often a full resync is not needed, but a partial
# resync is enough, just passing the portion of data the slave missed while
# disconnected.
# 设置复制backlog的大小。
# 积压是一个缓冲区，当从服务断开连接一段时间后，就会积累复制数据，这样当一个从服务想要重新连接时，通常不需要完全的重新同步，但是部分的重新同步就足够了，只是传递了在断开连接时丢失的数据的一部分。
#
# The bigger the replication backlog, the longer the time the slave can be
# disconnected and later be able to perform a partial resynchronization.
# 复制的积压越大，从服务断开连接的时间越长，以后就能够执行部分重新同步。
#
# The backlog is only allocated once there is at least a slave connected.
# 只有在至少有一个从服务连接的情况下，才会分配待办事项。
#
# repl-backlog-size 1mb


# After a master has no longer connected slaves for some time, the backlog
# will be freed. The following option configures the amount of seconds that
# need to elapse, starting from the time the last slave disconnected, for
# the backlog buffer to be freed.
# 当一个主服务不再连接从服务一段时间后，积压将被释放。
# 下面的选项配置所需的秒数，从最后一个从服务断开连接的时间开始，以便释放积压的缓冲区。
#
# Note that slaves never free the backlog for timeout, since they may be
# promoted to masters later, and should be able to correctly "partially
# resynchronize" with the slaves: hence they should always accumulate backlog.
# 要注意的是，从服务们从来没有把积压的工作时间释放出来，因为他们以后可能会被提升为主服务，并且应该能够正确地“部分地重新同步”和slave复制：因此他们应该总是积累积压的工作。
#
# A value of 0 means to never release the backlog.
# 0的值意味着永远不要释放积压。
#
# repl-backlog-ttl 3600


# The slave priority is an integer number published by Redis in the INFO output.
# It is used by Redis Sentinel in order to select a slave to promote into a
# master if the master is no longer working correctly.
# 从属优先级是由Redis在INFO输出中发布的整数编号。
# 它被Redis哨兵用来选择一个从服务，如果主服务不再正常工作，就可以把它提升为主服务。
#
# A slave with a low priority number is considered better for promotion, so
# for instance if there are three slaves with priority 10, 100, 25 Sentinel will
# pick the one with priority 10, that is the lowest.
#
# However a special priority of 0 marks the slave as not able to perform the
# role of master, so a slave with priority of 0 will never be selected by
# Redis Sentinel for promotion.
# 一个低优先级的从服务被认为是更好的晋升机会，例如，如果有三个从服务的优先级是10 100，那么25个哨兵将会选择优先级10的，这是最低的。
#
# By default the priority is 100.
# 默认情况下，优先级是100。
slave-priority 100


# It is possible for a master to stop accepting writes if there are less than
# N slaves connected, having a lag less or equal than M seconds.
# 如果有少于N个从服务的连接，有一个延迟小于或等于M秒，那么一个主服务就可以停止接受写。
#
# The N slaves need to be in "online" state.
# N个从服务需要处于“在线”状态。
#
# The lag in seconds, that must be <= the specified value, is calculated from
# the last ping received from the slave, that is usually sent every second.
# 秒的延迟，必须是<=指定的值，是从从服务收到的最后一个ping来计算的，这通常是每秒钟发送一次。
#
# This option does not GUARANTEE that N replicas will accept the write, but
# will limit the window of exposure for lost writes in case not enough slaves
# are available, to the specified number of seconds.
# 这个选项并不能保证N个副本将接受写入，但是如果没有足够的从服务可用，则将限制丢失的写入的窗口，以达到指定的秒数。
#
# For example to require at least 3 slaves with a lag <= 10 seconds use:
# 例如，至少需要3个有延迟<=10秒的从服务：
#
# min-slaves-to-write 3
# min-slaves-max-lag 10
#
# Setting one or the other to 0 disables the feature.
# 将一个或另一个设置为0禁用该特性。
#
# By default min-slaves-to-write is set to 0 (feature disabled) and
# min-slaves-max-lag is set to 10.
# 默认情况下，min-slaves-to-write被设置为0（功能禁用），而min-slaves-max-滞后设置为10。


# A Redis master is able to list the address and port of the attached
# slaves in different ways. For example the "INFO replication" section
# offers this information, which is used, among other tools, by
# Redis Sentinel in order to discover slave instances.
# Another place where this info is available is in the output of the
# "ROLE" command of a master.
# Redis的主服务能够以不同的方式列出所依附的从服务的地址和港口。
# 例如，“INFO复制”一节提供了这个信息，它在其他工具中使用，通过Redis Sentinel来发现从服务实例。
# 这个信息可用的另一个地方是在一个主的“角色”命令的输出中。
#
# The listed IP and address normally reported by a slave is obtained
# in the following way:
# 所列出的由从服务报告的IP地址和地址是通过以下方式获得的：
#
#   IP: The address is auto detected by checking the peer address
#   of the socket used by the slave to connect with the master.
#   通过检查从服务使用的socket的对等地址来连接主服务器，从而自动检测到地址。
#
#   Port: The port is communicated by the slave during the replication
#   handshake, and is normally the port that the slave is using to
#   list for connections.
#   这个端口是由从服务在复制握手过程中进行通信的，通常是从服务用来为连接列出的端口。
#
# However when port forwarding or Network Address Translation (NAT) is
# used, the slave may be actually reachable via different IP and port
# pairs. The following two options can be used by a slave in order to
# report to its master a specific set of IP and port, so that both INFO
# and ROLE will report those values.
# 然而，当使用端口转发或网络地址转换（NAT）时，可以通过不同的IP和端口对来访问从服务。一个从服务可以使用下面两个选项来向它的主服务报告一组特定的IP和端口，这样信息和角色就会报告这些值。
#
# There is no need to use both the options if you need to override just
# the port or the IP address.
# 如果您需要覆盖端口或IP地址，那么就不需要同时使用两个选项。
#
# slave-announce-ip 5.5.5.5
# slave-announce-port 1234
```
# 安全
```
################################## SECURITY 安全设置 ###################################


# Require clients to issue AUTH <PASSWORD> before processing any other
# commands.  This might be useful in environments in which you do not trust
# others with access to the host running redis-server.
# 要求客户在处理任何其他命令之前发出身份验证。这可能在您不相信其他人可以访问主机运行redis-server的环境中是有用的。
#
# This should stay commented out for backward compatibility and because most
# people do not need auth (e.g. they run their own servers).
# 对于向后兼容性，这应该被注释掉，因为大多数人不需要身份验证（例如，他们运行自己的服务器）。
#
# Warning: since Redis is pretty fast an outside user can try up to
# 150k passwords per second against a good box. This means that you should
# use a very strong password otherwise it will be very easy to break.
# 警告：由于Redis非常快，外部用户可以在一个好的盒子上每秒尝试150 k个密码。这意味着您应该使用一个非常强的密码，否则它将很容易被破解。
#
# requirepass foobared


# Command renaming.
# 命令重命名。
#
# It is possible to change the name of dangerous commands in a shared
# environment. For instance the CONFIG command may be renamed into something
# hard to guess so that it will still be available for internal-use tools
# but not available for general clients.
# 在共享环境中更改危险命令的名称是可能的。
# 例如，配置命令可能会被重命名为难以猜测的东西，这样它仍然可以用于内部使用工具，但对于一般客户来说是不可用的。
#
# Example:
# 例子:
#
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
# It is also possible to completely kill a command by renaming it into
# an empty string:
# 也可以通过将命令重命名为空字符串来完全杀死一个命令：
#
# rename-command CONFIG ""
#
# Please note that changing the name of commands that are logged into the
# AOF file or transmitted to slaves may cause problems.
# 请注意，更改登录到AOF文件或传输给从服务的命令的名称可能会导致问题。

```

# 客户端
```
################################### CLIENTS 客户端设置 ####################################


# Set the max number of connected clients at the same time. By default
# this limit is set to 10000 clients, however if the Redis server is not
# able to configure the process file limit to allow for the specified limit
# the max number of allowed clients is set to the current file limit
# minus 32 (as Redis reserves a few file descriptors for internal uses).
# 在同一时间设置连接客户端的最大数量。
# 默认情况下这个限制设置为10000个客户,但是如果复述,服务器不能配置过程文件限制允许指定限制允许的最大数量的客户设置为当前文件限制- 32(复述,储备一些为内部使用文件描述符)。
#
# Once the limit is reached Redis will close all the new connections sending
# an error 'max number of clients reached'.
# 一旦达到限制，Redis将关闭所有的新连接，发送一个错误的“最大客户数量”。
#
# maxclients 10000
```

# 内存管理
```
############################## MEMORY MANAGEMENT 内存管理 ################################


# Set a memory usage limit to the specified amount of bytes.
# When the memory limit is reached Redis will try to remove keys
# according to the eviction policy selected (see maxmemory-policy).
# 将内存使用限制设置为指定的字节数。当达到内存限制时，Redis会根据选择的驱逐策略（参见max内存策略）来删除键。
#
# If Redis can't remove keys according to the policy, or if the policy is
# set to 'noeviction', Redis will start to reply with errors to commands
# that would use more memory, like SET, LPUSH, and so on, and will continue
# to reply to read-only commands like GET.
# 如果Redis不能根据政策删除键，或者如果策略被设置为“noeviction”，那么Redis将开始以错误的方式回复那些使用更多内存的命令，比如SET、LPUSH等等，并将继续回复诸如GET这样的只读命令。
#
# This option is usually useful when using Redis as an LRU or LFU cache, or to
# set a hard memory limit for an instance (using the 'noeviction' policy).
# 当使用Redis作为LRU或LFU缓存时，这个选项通常很有用，或者为一个实例设置一个硬内存限制（使用“noeviction”策略）。
#
# WARNING: If you have slaves attached to an instance with maxmemory on,
# the size of the output buffers needed to feed the slaves are subtracted
# from the used memory count, so that network problems / resyncs will
# not trigger a loop where keys are evicted, and in turn the output
# buffer of slaves is full with DELs of keys evicted triggering the deletion
# of more keys, and so forth until the database is completely emptied.
# 警告:如果你有从服务与maxmemory连接到一个实例,输出缓冲区的大小需要喂从服务使用内存数相减时,这网络问题/同步不会触发一个键被驱逐的循环,进而从服务的输出缓冲区满del键驱逐触发的删除键,直到完全清空数据库等等。
#
# In short... if you have slaves attached it is suggested that you set a lower
# limit for maxmemory so that there is some free RAM on the system for slave
# output buffers (but this is not needed if the policy is 'noeviction').
# 总之……如果你有从服务，建议你为maxmemory设定一个较低的限制，这样系统就会有一些免费的RAM来实现从服务输出缓冲区（但是如果策略是“no驱逐”的话，这是不需要的）。
#
# maxmemory <bytes>


# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
# is reached. You can select among five behaviors:
# MAXMEMORY策略：当到达MAXMEMORY时，Redis将如何选择移除哪些内容。你可以在以下五种行为中进行选择：
#
# volatile-lru -> Evict using approximated LRU among the keys with an expire set.
#                 在带有过期设置的键中使用近似LRU。
# allkeys-lru -> Evict any key using approximated LRU.
#                使用近似的LRU将任何键驱逐。
# volatile-lfu -> Evict using approximated LFU among the keys with an expire set.
#                 使用近似的LFU在带有过期集的键之间进行驱逐。
# allkeys-lfu -> Evict any key using approximated LFU.
#                用近似的LFU清除任何键。
# volatile-random -> Remove a random key among the ones with an expire set.
#                    在带有过期设置的键中删除一个随机键。
# allkeys-random -> Remove a random key, any key.
#                   删除一个随机键，任何键。
# volatile-ttl -> Remove the key with the nearest expire time (minor TTL)
#                 用最近的过期时间（小TTL）删除键
# noeviction -> Don't evict anything, just return an error on write operations.
#               不要驱逐任何东西，只是在写操作上返回一个错误。
#
# LRU means Least Recently Used
# LRU的意思是最近最少使用的
# LFU means Least Frequently Used
# LFU的意思是最不常用的
#
# Both LRU, LFU and volatile-ttl are implemented using approximated
# randomized algorithms.
# LRU、LFU和挥发-ttl都是用近似的随机算法实现的。
#
# Note: with any of the above policies, Redis will return an error on write
#       operations, when there are no suitable keys for eviction.
# 注意：在上述任何策略中，Redis会在写操作时返回一个错误，因为没有合适的键可以被驱逐。
#
#       At the date of writing these commands are: set setnx setex append
#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
#       getset mset msetnx exec sort
#       在写这些命令的时候，这些命令是：set setnx setex append
#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
#
# The default is:
# 默认的是:
#
# maxmemory-policy noeviction


# LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated
# algorithms (in order to save memory), so you can tune it for speed or
# accuracy. For default Redis will check five keys and pick the one that was
# used less recently, you can change the sample size using the following
# configuration directive.
# LRU、LFU和最小TTL算法不是精确的算法，而是近似算法（为了节省内存），所以您可以对它进行优化，以获得速度或准确性。
# 默认情况下，Redis会检查5个键，并选择最近使用较少的键，您可以使用下面的配置指令更改样本大小。
#
# The default of 5 produces good enough results. 10 Approximates very closely
# true LRU but costs more CPU. 3 is faster but not very accurate.
# 5的默认值会产生足够好的结果。10近似于非常接近的LRU，但花费更多的CPU。3是更快，但不是很准确。
#
# maxmemory-samples 5

```

# Lazy
```config
############################# LAZY FREEING 懒惰的释放 ####################################


# Redis has two primitives to delete keys. One is called DEL and is a blocking
# deletion of the object. It means that the server stops processing new commands
# in order to reclaim all the memory associated with an object in a synchronous
# way. If the key deleted is associated with a small object, the time needed
# in order to execute the DEL command is very small and comparable to most other
# O(1) or O(log_N) commands in Redis. However if the key is associated with an
# aggregated value containing millions of elements, the server can block for
# a long time (even seconds) in order to complete the operation.
# Redis有两个原语来删除键。一种叫做DEL，是对对象的阻塞删除。
# 这意味着服务器停止处理新的命令，以便以同步方式回收与对象相关联的所有内存。
# 如果被删除的键与一个小对象相关联，那么执行DEL命令所需的时间非常小，并且可以与Redis中的大多数O（1）或O（logn）命令相媲美。
# 然而，如果密钥与包含数百万个元素的聚合值相关联，那么服务器就可以阻塞很长时间（甚至几秒），以完成操作。
#
# For the above reasons Redis also offers non blocking deletion primitives
# such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and
# FLUSHDB commands, in order to reclaim memory in background. Those commands
# are executed in constant time. Another thread will incrementally free the
# object in the background as fast as possible.
# 出于以上原因，Redis还提供非阻塞删除原语，如UNLINK（非阻塞DEL）和FLUSHALL和FLUSHDB命令的异步选项，以便在后台回收内存。
# 这些命令是在固定时间执行的。另一个线程会以最快的速度在后台以增量方式释放对象。
#
# DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.
# It's up to the design of the application to understand when it is a good
# idea to use one or the other. However the Redis server sometimes has to
# delete keys or flush the whole database as a side effect of other operations.
# Specifically Redis deletes objects independently of a user call in the
# following scenarios:
# DEL、UNLINK和FLUSHDB的异步选项是用户控制的。这取决于应用程序的设计，以了解什么时候使用一个或另一个是一个好主意。
# 然而，Redis服务器有时不得不删除键或刷新整个数据库，作为其他操作的副作用。具体来说，Redis在以下场景中独立于用户调用删除对象：
#
# 1) On eviction, because of the maxmemory and maxmemory policy configurations,
#    in order to make room for new data, without going over the specified
#    memory limit.
#    在被驱逐的情况下，由于maxmemory和maxmemory政策配置，为了为新数据腾出空间，而不需要超过指定的内存限制。
# 2) Because of expire: when a key with an associated time to live (see the
#    EXPIRE command) must be deleted from memory.
#    因为过期：当一个有关联时间的键（见过期命令）必须从内存中删除。
# 3) Because of a side effect of a command that stores data on a key that may
#    already exist. For example the RENAME command may delete the old key
#    content when it is replaced with another one. Similarly SUNIONSTORE
#    or SORT with STORE option may delete existing keys. The SET command
#    itself removes any old content of the specified key in order to replace
#    it with the specified string.
#    因为一个命令的副作用，它将数据存储在可能已经存在的键上。
#    例如，RENAME命令可能会在替换旧钥匙内容时删除另一个。
#    类似的，SUNIONSTORE或SORT商店选项可以删除现有的密钥。SET命令本身删除指定钥匙的任何旧内容，以便用指定的字符串替换它。
# 4) During replication, when a slave performs a full resynchronization with
#    its master, the content of the whole database is removed in order to
#    load the RDB file just transfered.
#    在复制过程中，当一个从服务与它的主服务执行完全的重新同步时，整个数据库的内容将被删除，以便加载刚刚传输的RDB文件。
#
# In all the above cases the default is to delete objects in a blocking way,
# like if DEL was called. However you can configure each case specifically
# in order to instead release memory in a non-blocking way like if UNLINK
# was called, using the following configuration directives:
# 在上述所有情况下，默认情况下是以阻塞方式删除对象，就像调用DEL一样。但是，您可以专门配置每个案例，以便以非阻塞方式释放内存，就像调用UNLINK一样，使用以下配置指令：


lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
slave-lazy-flush no
```

# LUA Script 脚本
```config
################################ LUA SCRIPTING LUA脚本 ###############################


# Max execution time of a Lua script in milliseconds.
# 以毫秒为间隔的Lua脚本执行时间。
#
# If the maximum execution time is reached Redis will log that a script is
# still in execution after the maximum allowed time and will start to
# reply to queries with an error.
# 如果达到最大执行时间，Redis将会记录一个脚本在允许的最大时间之后仍然在执行，并且将开始以错误的方式回复查询。
#
# When a long running script exceeds the maximum execution time only the
# SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be
# used to stop a script that did not yet called write commands. The second
# is the only way to shut down the server in the case a write command was
# already issued by the script but the user doesn't want to wait for the natural
# termination of the script.
# 当一个长时间运行的脚本超过了最大执行时间时，只有脚本杀死和关闭NOSAVE命令。
# 第一个可以用来阻止一个还没有调用write命令的脚本。
# 第二种方法是关闭服务器的唯一方法，在这种情况下，脚本已经发布了一个写命令，但是用户不希望等待脚本的自然终止。
#
# Set it to 0 or a negative value for unlimited execution without warnings.
# 将其设置为0或负值，以无限制地执行，而不需要警告。
lua-time-limit 5000
```

# 哨兵
```config
################################ REDIS CLUSTER 集群配置  ###############################
#
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# WARNING EXPERIMENTAL: Redis Cluster is considered to be stable code, however
# in order to mark it as "mature" we need to wait for a non trivial percentage
# of users to deploy it in production.
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# 警告实验：Redis集群被认为是稳定的代码，但是为了将其标记为“成熟”，我们需要等待一个非平凡的用户在生产中部署它。
#
# Normal Redis instances can't be part of a Redis Cluster; only nodes that are
# started as cluster nodes can. In order to start a Redis instance as a
# cluster node enable the cluster support uncommenting the following:
# 正常的Redis实例不能成为Redis集群的一部分;只有作为集群节点启动的节点才可以。为了启动一个Redis实例作为集群节点，集群支持取消注释以下内容：
#
# cluster-enabled yes


# Every cluster node has a cluster configuration file. This file is not
# intended to be edited by hand. It is created and updated by Redis nodes.
# Every Redis Cluster node requires a different cluster configuration file.
# Make sure that instances running in the same system do not have
# overlapping cluster configuration file names.
# 每个集群节点都有一个集群配置文件。
# 这个文件不打算手工编辑。
# 它是由Redis节点创建和更新的。
# 每个Redis集群节点都需要一个不同的集群配置文件。
# 确保在同一个系统中运行的实例没有重叠的集群配置文件名。
#
# cluster-config-file nodes-6379.conf


# Cluster node timeout is the amount of milliseconds a node must be unreachable
# for it to be considered in failure state.
# Most other internal time limits are multiple of the node timeout.
# 集群节点超时是节点必须不可访问的毫秒数，以便在故障状态下考虑它。
# 大多数其他内部时间限制是节点超时的倍数。
#
# cluster-node-timeout 15000


# A slave of a failing master will avoid to start a failover if its data
# looks too old.
# 如果数据看起来太旧，故障管理员的从服务将避免启动故障转移。
#
# There is no simple way for a slave to actually have an exact measure of
# its "data age", so the following two checks are performed:
# 对于一个从服务来说，没有一种简单的方法可以精确地测量它的“数据年龄”，因此执行以下两项检查：
#
# 1) If there are multiple slaves able to failover, they exchange messages
#    in order to try to give an advantage to the slave with the best
#    replication offset (more data from the master processed).
#    Slaves will try to get their rank by offset, and apply to the start
#    of the failover a delay proportional to their rank.
#    如果有多个从服务能够进行故障转移，他们交换消息，以试图通过最佳复制偏移（更多来自主处理的数据）给从服务带来优势。
#    从服务将试图通过偏移来获得他们的等级，并应用到故障转移的开始，这是与他们的等级成比例的延迟。
#
# 2) Every single slave computes the time of the last interaction with
#    its master. This can be the last ping or command received (if the master
#    is still in the "connected" state), or the time that elapsed since the
#    disconnection with the master (if the replication link is currently down).
#    If the last interaction is too old, the slave will not try to failover
#    at all.
#    每一个从服务计算最后一次与主服务的互动的时间。
#    这可以是最后一次ping或命令（如果主仍然处于“连接的”状态），或者是与主断开连接后的时间（如果复制链接当前正在关闭）。
#    如果最后一次交互太旧，那么从服务将不会尝试进行故障转移。
#
# The point "2" can be tuned by user. Specifically a slave will not perform
# the failover if, since the last interaction with the master, the time
# elapsed is greater than:
# “2”可以由用户调优。
# 具体来说，如果从与主的最后一次交互中，一个从服务将不会执行故障转移，因为时间的流逝比：
#
#   (node-timeout * slave-validity-factor) + repl-ping-slave-period
#
# So for example if node-timeout is 30 seconds, and the slave-validity-factor
# is 10, and assuming a default repl-ping-slave-period of 10 seconds, the
# slave will not try to failover if it was not able to talk with the master
# for longer than 310 seconds.
# 例如，如果node-timeout是30秒，slave-validity-facto是10，假设默认的回复周期为10秒，如果不能与主对话超过310秒，则该从服务将不会尝试进行故障转移。
#
# A large slave-validity-factor may allow slaves with too old data to failover
# a master, while a too small value may prevent the cluster from being able to
# elect a slave at all.
# 一个slave-validity-factor可能允许拥有太旧数据的从服务能够对主服务进行故障转移，而一个太小的值可能会阻止集群完全选择一个从服务。
#
# For maximum availability, it is possible to set the slave-validity-factor
# to a value of 0, which means, that slaves will always try to failover the
# master regardless of the last time they interacted with the master.
# (However they'll always try to apply a delay proportional to their
# offset rank).
# 为了获得最大的可用性，可以将斯拉夫有效因子设置为0，也就是说，无论最后一次与主交互的时间，从服务总是试图对主服务器进行故障转移。
#（然而，他们总是试图将延迟与他们的偏移量成比例）。
#
# Zero is the only value able to guarantee that when all the partitions heal
# the cluster will always be able to continue.
# 零是唯一能够保证当所有分区恢复时，集群将始终能够继续的值。
#
# cluster-slave-validity-factor 10


# Cluster slaves are able to migrate to orphaned masters, that are masters
# that are left without working slaves. This improves the cluster ability
# to resist to failures as otherwise an orphaned master can't be failed over
# in case of failure if it has no working slaves.
# 集群的从服务能够迁移到孤立的主服务那里，这些主服务是没有工作的从服务的主服务。
# 这提高了集群抵御失败的能力，否则，如果没有工作的从服务，一个孤立的主服务就不能失败。
#
# Slaves migrate to orphaned masters only if there are still at least a
# given number of other working slaves for their old master. This number
# is the "migration barrier". A migration barrier of 1 means that a slave
# will migrate only if there is at least 1 other working slave for its master
# and so forth. It usually reflects the number of slaves you want for every
# master in your cluster.
# 只有在为老主服务至少有一定数量的其他工作从服务的情况下，从服务才会迁移到孤立的主服务那里。
# 这个数字是“移民障碍”。
# 一个1的迁移屏障意味着只有当一个从服务至少有一个其他的工作从服务时，从服务才会迁移。
# 它通常反映了你想要的每一个主服务的从服务数量。
#
# Default is 1 (slaves migrate only if their masters remain with at least
# one slave). To disable migration just set it to a very large value.
# A value of 0 can be set but is useful only for debugging and dangerous
# in production.
# 默认值是1（只有当主服务至少有一个从服务时，从服务才会迁移）。
# 要禁用迁移，只需将其设置为非常大的值。
# 可以设置0的值，但是只对调试和生产中的危险有用。
#
# cluster-migration-barrier 1


# By default Redis Cluster nodes stop accepting queries if they detect there
# is at least an hash slot uncovered (no available node is serving it).
# This way if the cluster is partially down (for example a range of hash slots
# are no longer covered) all the cluster becomes, eventually, unavailable.
# It automatically returns available as soon as all the slots are covered again.
# 默认情况下，Redis集群节点会停止接受查询，如果它们检测到至少有一个散列槽被发现（没有可用的节点正在服务它）。
# 这样，如果集群部分下降（例如，不再覆盖多个散列槽），所有集群最终都将不可用。
# 一旦所有的槽被再次覆盖，它就会自动返回。
#
# However sometimes you want the subset of the cluster which is working,
# to continue to accept queries for the part of the key space that is still
# covered. In order to do so, just set the cluster-require-full-coverage
# option to no.
# 然而，有时您想要的是正在工作的集群的子集，继续接受仍然覆盖的关键空间部分的查询。
# 为了做到这一点，只需将集群需求全覆盖选项设置为no。
#
# cluster-require-full-coverage yes


# In order to setup your cluster make sure to read the documentation
# available at http://redis.io web site.
# 为了设置您的集群，请确保阅读http://redis上的文档
```

# SlowLog
```config
################################## SLOW LOG 慢日志 ###################################


# The Redis Slow Log is a system to log queries that exceeded a specified
# execution time. The execution time does not include the I/O operations
# like talking with the client, sending the reply and so forth,
# but just the time needed to actually execute the command (this is the only
# stage of command execution where the thread is blocked and can not serve
# other requests in the meantime).
# Redis慢速日志是一个记录超过指定执行时间的查询的系统。
# 执行时间不包括I / O操作,比如与客户端,发送应答等等,但就实际执行命令所需的时间(这是唯一阶段命令执行的线程被阻塞,不能同时处理其他请求)。
#
# You can configure the slow log with two parameters: one tells Redis
# what is the execution time, in microseconds, to exceed in order for the
# command to get logged, and the other parameter is the length of the
# slow log. When a new command is logged the oldest one is removed from the
# queue of logged commands.
# 您可以用两个参数来配置慢日志：一个告诉Redis什么是执行时间，以微秒计，以使命令被记录下来，而另一个参数是慢日志的长度。当一个新的命令被记录时，最老的命令将从已登录的命令的队列中删除。


# The following time is expressed in microseconds, so 1000000 is equivalent
# to one second. Note that a negative number disables the slow log, while
# a value of zero forces the logging of every command.
# 下面的时间以微秒表示，所以1000000等于一秒。
# 注意，一个负数禁用慢速日志，而值为0则会强制每个命令的日志记录。
slowlog-log-slower-than 10000


# There is no limit to this length. Just be aware that it will consume memory.
# You can reclaim memory used by the slow log with SLOWLOG RESET.
# 这个长度是没有限制的。
# 只要意识到它会消耗内存。
# 您可以使用慢速日志重置慢速日志所使用的内存。
slowlog-max-len 128
```

#CLUSTER DOCKER/NAT support 集群DOCKER/NAT支持
```
########################## CLUSTER DOCKER/NAT support 集群DOCKER/NAT支持  ########################


# In certain deployments, Redis Cluster nodes address discovery fails, because
# addresses are NAT-ted or because ports are forwarded (the typical case is
# Docker and other containers).
# 在某些部署中，Redis集群节点地址发现失败，因为地址是NAT-ted，或者因为端口被转发（典型的例子是Docker和其他容器）。
#
# In order to make Redis Cluster working in such environments, a static
# configuration where each node knows its public address is needed. The
# following two options are used for this scope, and are:
# 为了使Redis集群在这样的环境中工作，需要一个静态配置，其中每个节点都知道它的公共地址。下面两个选项用于这个范围，并且是：
#
# * cluster-announce-ip
# * cluster-announce-port
# * cluster-announce-bus-port
#
# Each instruct the node about its address, client port, and cluster message
# bus port. The information is then published in the header of the bus packets
# so that other nodes will be able to correctly map the address of the node
# publishing the information.
# 每个节点都指示节点关于其地址、客户端端口和集群消息总线端口。
# 然后，这些信息将在总线数据包的头部中发布，这样其他节点就能够正确地映射出发布信息的节点的地址。
#
# If the above options are not used, the normal Redis Cluster auto-detection
# will be used instead.
# 如果不使用上述选项，则将使用常规的Redis集群自动检测。
#
# Note that when remapped, the bus port may not be at the fixed offset of
# clients port + 10000, so you can specify any port and bus-port depending
# on how they get remapped. If the bus-port is not set, a fixed offset of
# 10000 will be used as usually.
# 注意，当重新映射时，总线端口可能不会处于客户端端口+10000的固定偏移量，因此您可以根据它们的重新映射来指定任何端口和总线端口。
# 如果没有设置公共汽车端口，则通常会使用1万的固定偏移量。
#
# Example:
#
# cluster-announce-ip 10.1.1.5
# cluster-announce-port 6379
# cluster-announce-bus-port 6380
```

# 延迟监控
```
################################ LATENCY MONITOR 延迟监控 ##############################


# The Redis latency monitoring subsystem samples different operations
# at runtime in order to collect data related to possible sources of
# latency of a Redis instance.
# Redis延迟监视子系统在运行时对不同的操作进行取样，以便收集与Redis实例可能的延迟源相关的数据。
#
# Via the LATENCY command this information is available to the user that can
# print graphs and obtain reports.
# 通过延迟命令，该信息对能够打印图形并获得报告的用户可用。
#
# The system only logs operations that were performed in a time equal or
# greater than the amount of milliseconds specified via the
# latency-monitor-threshold configuration directive. When its value is set
# to zero, the latency monitor is turned off.
# 该系统只记录在一个时间内执行的操作，该操作的时间等于或大于通过延迟监控阈值配置指令指定的毫秒数。
# 当它的值被设置为0时，延迟监视器将被关闭。
#
# By default latency monitoring is disabled since it is mostly not needed
# if you don't have latency issues, and collecting data has a performance
# impact, that while very small, can be measured under big load. Latency
# monitoring can easily be enabled at runtime using the command
# "CONFIG SET latency-monitor-threshold <milliseconds>" if needed.
# 在默认情况下，延迟监控是禁用的，因为如果没有延迟问题，通常不需要延迟，而收集数据具有性能影响，虽然非常小，但可以在大负载下进行测量。
# 如果需要，可以很容易地在运行时启用延迟监控，使用“配置集设置器-监控-阈值”。
latency-monitor-threshold 0
```

# 时间通知
```
############################# EVENT NOTIFICATION 事件通知 ##############################


# Redis can notify Pub/Sub clients about events happening in the key space.
# This feature is documented at http://redis.io/topics/notifications
# Redis可以通知发布订阅客户关于在密钥空间中发生的事件。
# 该特性可在http://redis.io/topics/通知中记录
#
# For instance if keyspace events notification is enabled, and a client
# performs a DEL operation on key "foo" stored in the Database 0, two
# messages will be published via Pub/Sub:
# 例如，如果启用了keyspace事件通知，并且客户端对存储在数据库0中的键“foo”执行DEL操作，那么两个消息将通过发布/订阅发布：
#
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
# It is possible to select the events that Redis will notify among a set
# of classes. Every class is identified by a single character:
# 可以选择Redis在一组类中通知的事件。每个类都由一个字符来标识：
#
#  K     Keyspace events, published with __keyspace@<db>__ prefix.
#        键空间事件，用__keyspace@<db>__前缀发布。
#  E     Keyevent events, published with __keyevent@<db>__ prefix.
#        键空间事件，用__keyevent@<db>__前缀发布。
#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
#        通用命令（非特定类型），如DEL，过期，重命名，……
#  $     String commands
#        字符串的命令
#  l     List commands
#        列表命令
#  s     Set commands
#        设置命令
#  h     Hash commands
#        散列的命令
#  z     Sorted set commands
#        排序设置命令
#  x     Expired events (events generated every time a key expires)
#        过期事件（每次密钥过期时生成的事件）
#  e     Evicted events (events generated when a key is evicted for maxmemory)
#        被驱逐的事件（当一个钥匙被驱逐到maxmemory时产生的事件）
#  A     Alias for g$lshzxe, so that the "AKE" string means all the events.
#        g$lshzxe的别名，因此“AKE”字符串意味着所有的事件。
#
#  The "notify-keyspace-events" takes as argument a string that is composed
#  of zero or multiple characters. The empty string means that notifications
#  are disabled.
#  “notify-keyspace-events”以一个由零个或多个字符组成的字符串作为参数。空字符串表示通知是禁用的。
#
#  Example: to enable list and generic events, from the point of view of the
#           event name, use:
#           为了启用列表和泛型事件，从事件名称的角度来看，使用：
#
#  notify-keyspace-events Elg
#
#  Example 2: to get the stream of the expired keys subscribing to channel
#             name __keyevent@0__:expired use:
#             要获得过期密钥的流，订阅频道名称 __keyevent@0__:expired使用：
#
#  notify-keyspace-events Ex
#
#  By default all notifications are disabled because most users don't need
#  this feature and the feature has some overhead. Note that if you don't
#  specify at least one of K or E, no events will be delivered.
#  默认情况下，所有通知都是禁用的，因为大多数用户不需要这个特性，而且该特性也有一些开销。
#  注意，如果您没有指定至少一个K或E，则不会交付任何事件。
notify-keyspace-events ""

```


# 高级配置
```
############################### ADVANCED CONFIG 高级配置 ###############################


# Hashes are encoded using a memory efficient data structure when they have a
# small number of entries, and the biggest entry does not exceed a given
# threshold. These thresholds can be configured using the following directives.
# 当它们有少量的条目时，使用内存高效的数据结构进行编码，而最大的条目不会超过给定的阈值。这些阈值可以使用下列指令进行配置。
hash-max-ziplist-entries 512
hash-max-ziplist-value 64


# Lists are also encoded in a special way to save a lot of space.
# 列表也以一种特殊的方式进行编码，以节省大量的空间。
# The number of entries allowed per internal list node can be specified
# as a fixed maximum size or a maximum number of elements.
# 每个内部列表节点允许的条目数可以指定为固定的最大大小或最大数量的元素。
# For a fixed maximum size, use -5 through -1, meaning:
# 对于一个固定的最大尺寸，使用-5到-1，意思是：
# -5: max size: 64 Kb  <-- not recommended for normal workloads
#                          不建议正常工作负载
# -4: max size: 32 Kb  <-- not recommended
#                          不推荐
# -3: max size: 16 Kb  <-- probably not recommended
#                          可能不推荐
# -2: max size: 8 Kb   <-- good
#                          好
# -1: max size: 4 Kb   <-- good
#                          好
# Positive numbers mean store up to _exactly_ that number of elements
# per list node.
# 正号意味着每个列表节点的元素数量都是如此。
# The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),
# but if your use case is unique, adjust the settings as necessary.
# 性能最高的选项通常是-2（8 Kb大小）或-1（4 Kb大小），但是如果您的用例是惟一的，那么根据需要调整设置。
list-max-ziplist-size -2


# Lists may also be compressed.
# 列表也可能被压缩。
# Compress depth is the number of quicklist ziplist nodes from *each* side of
# the list to *exclude* from compression.  The head and tail of the list
# are always uncompressed for fast push/pop operations.  Settings are:
# 压缩深度是列表的每一端的quicklist ziplist节点的数量，以排除压缩。列表的头和尾总是未被压缩，以快速的推送/pop操作。设置:
# 0: disable all list compression
#    禁用所有列表压缩
# 1: depth 1 means "don't start compressing until after 1 node into the list,
#    going from either the head or tail"
#    深度1的意思是“不要开始压缩，直到1个节点进入列表，从头部或尾部开始”
#    So: [head]->node->node->...->node->[tail]
#    [head], [tail] will always be uncompressed; inner nodes will compress.
#                   永远是未压缩的;内部节点将压缩。
# 2: [head]->[next]->node->node->...->node->[prev]->[tail]
#    2 here means: don't compress head or head->next or tail->prev or tail,
#    but compress all nodes between them.
#    这里的意思是：不要压缩头或头——下一个或尾->prev或tail，而是压缩它们之间的所有节点。
# 3: [head]->[next]->[next]->node->node->...->node->[prev]->[prev]->[tail]
# etc.
list-compress-depth 0


# Sets have a special encoding in just one case: when a set is composed
# of just strings that happen to be integers in radix 10 in the range
# of 64 bit signed integers.
# set在一个案例中有一个特殊的编码：当一个集合由只有在64位签名整数的基数上的整数组成的字符串组成时。
# The following configuration setting sets the limit in the size of the
# set in order to use this special memory saving encoding.
# 下面的配置设置设置了集合大小的限制，以便使用这种特殊的内存保存编码。
set-max-intset-entries 512


# Similarly to hashes and lists, sorted sets are also specially encoded in
# order to save a lot of space. This encoding is only used when the length and
# elements of a sorted set are below the following limits:
# 类似于哈希表和列表，排序集也经过特殊编码，以节省大量空间。
# 只有当排序集的长度和元素低于以下限制时才使用这种编码：
zset-max-ziplist-entries 128
zset-max-ziplist-value 64


# HyperLogLog sparse representation bytes limit. The limit includes the
# 16 bytes header. When an HyperLogLog using the sparse representation crosses
# this limit, it is converted into the dense representation.
# 超loglog稀疏表示字节限制。
# 这个限制包括16个字节的头。
# 当使用稀疏表示的超loglog跨越这个极限时，它就会被转换成密集的表示形式。
#
# A value greater than 16000 is totally useless, since at that point the
# dense representation is more memory efficient.
# 大于16000的值是完全无用的，因为在这一点上，密集的表示更有效。
#
# The suggested value is ~ 3000 in order to have the benefits of
# the space efficient encoding without slowing down too much PFADD,
# which is O(N) with the sparse encoding. The value can be raised to
# ~ 10000 when CPU is not a concern, but space is, and the data set is
# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.
# 建议的值是3000，以获得空间高效编码的好处，而不会减慢太多的PFADD，即O（N）与稀疏编码。
# 当CPU不是一个问题时，它的值可以提高到10000，但是空间是，并且数据集是由许多具有基数在0-15000范围的超loglogs组成的。
hll-sparse-max-bytes 3000


# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in
# order to help rehashing the main Redis hash table (the one mapping top-level
# keys to values). The hash table implementation Redis uses (see dict.c)
# performs a lazy rehashing: the more operation you run into a hash table
# that is rehashing, the more rehashing "steps" are performed, so if the
# server is idle the rehashing is never complete and some more memory is used
# by the hash table.
# 活跃的重放使用每100毫秒的CPU时间1毫秒，以帮助重放主Redis哈希表（一个映射顶级键到值）。
# 哈希表实现复述,使用(见dict.c)执行一个懒惰改作:操作越多改作遇到一个哈希表,越改作“步骤”执行,如果服务器空闲时再处理就不算完整和一些更多的内存使用哈希表。
#
# The default is to use this millisecond 10 times every second in order to
# actively rehash the main dictionaries, freeing memory when possible.
# 默认情况下，每秒钟使用这个毫秒10次，以便积极地对主字典进行重新处理，尽可能地释放内存。
#
# If unsure:
# use "activerehashing no" if you have hard latency requirements and it is
# not a good thing in your environment that Redis can reply from time to time
# to queries with 2 milliseconds delay.
# 如果不确定:
# 如果您有严格的延迟需求，那么使用“activerehash no”，在您的环境中，Redis可以不时地回复到2毫秒延迟的查询，这不是一件好事。
#
# use "activerehashing yes" if you don't have such hard requirements but
# want to free memory asap when possible.
# 如果你没有这样的硬性要求，那么就使用“activerehash”，但如果可能的话，希望尽快释放内存。
activerehashing yes


# The client output buffer limits can be used to force disconnection of clients
# that are not reading data from the server fast enough for some reason (a
# common reason is that a Pub/Sub client can't consume messages as fast as the
# publisher can produce them).
# 客户端输出缓冲限制可以用来强制那些由于某种原因而不能快速读取服务器数据的客户端断开（一个常见的原因是，发布/订阅客户端不能像发布者所能生成的那样快速地使用消息）。
#
# The limit can be set differently for the three different classes of clients:
# 对于这三种不同类型的客户，可以设置不同的限制：
#
# normal -> normal clients including MONITOR clients
#           正常的客户端包括监控客户端
# slave  -> slave clients
#           从服务客户端
# pubsub -> clients subscribed to at least one pubsub channel or pattern
#           客户至少订阅了一个pubsub通道或模式
#
# The syntax of every client-output-buffer-limit directive is the following:
# 每个客户-输出-缓冲区-限制指令的语法如下：
#
# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
#
# A client is immediately disconnected once the hard limit is reached, or if
# the soft limit is reached and remains reached for the specified number of
# seconds (continuously).
# 当达到硬限制时，客户端立即断开连接，或者如果达到了软限制，并且在指定的秒数（连续）中保持了联系。
# So for instance if the hard limit is 32 megabytes and the soft limit is
# 16 megabytes / 10 seconds, the client will get disconnected immediately
# if the size of the output buffers reach 32 megabytes, but will also get
# disconnected if the client reaches 16 megabytes and continuously overcomes
# the limit for 10 seconds.
# 比如如果硬限制是32字节和软限制是16 mb / 10秒,客户端会立即断开输出缓冲区的大小达到32字节,但也会断开如果客户达到16字节,不断克服了限制10秒钟。
#
# By default normal clients are not limited because they don't receive data
# without asking (in a push way), but just after a request, so only
# asynchronous clients may create a scenario where data is requested faster
# than it can read.
# 默认情况下，普通客户端并不受限制，因为他们不需要（以推的方式）请求数据，而是在请求之后才接收数据，因此只有异步客户端可能会创建一个场景，其中的数据被请求的速度比它所能读取的要快。
#
# Instead there is a default limit for pubsub and slave clients, since
# subscribers and slaves receive data in a push fashion.
# 相反，对于pubsub和从服务客户端有一个默认的限制，因为订阅者和从服务以一种推的方式接收数据。
#
# Both the hard or the soft limit can be disabled by setting them to zero.
# 硬的或软的限制都可以通过将它们设置为零来禁用。
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60


# Redis calls an internal function to perform many background tasks, like
# closing connections of clients in timeout, purging expired keys that are
# never requested, and so forth.
# Redis调用内部函数来执行许多后台任务，比如关闭超时的客户端连接，清除从未请求过的过期密钥，等等。
#
# Not all tasks are performed with the same frequency, but Redis checks for
# tasks to perform according to the specified "hz" value.
# 并不是所有的任务都使用相同的频率执行，但是Redis检查任务按照指定的“hz”值执行。
#
# By default "hz" is set to 10. Raising the value will use more CPU when
# Redis is idle, but at the same time will make Redis more responsive when
# there are many keys expiring at the same time, and timeouts may be
# handled with more precision.
# 默认情况下，“hz”设置为10。
# 当Redis空闲时，提高值将会使用更多的CPU，但同时，当有许多键同时到期时，Redis会更有响应性，并且可以更精确地处理超时。
#
# The range is between 1 and 500, however a value over 100 is usually not
# a good idea. Most users should use the default of 10 and raise this up to
# 100 only in environments where very low latency is required.
# 范围在1到500之间，但是超过100的值通常不是一个好主意。
# 大多数用户应该使用默认的10，并且只在需要非常低的延迟的环境中将其提高到100。
hz 10


# When a child rewrites the AOF file, if the following option is enabled
# the file will be fsync-ed every 32 MB of data generated. This is useful
# in order to commit the file to the disk more incrementally and avoid
# big latency spikes.
# 当一个子进程重新编写AOF文件时，如果启用了下列选项，那么该文件将会被fsync-ed所生成的每32 MB的数据。这对于将文件提交到磁盘上更有帮助，并避免大的延迟峰值是很有用的。
aof-rewrite-incremental-fsync yes


# Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good
# idea to start with the default settings and only change them after investigating
# how to improve the performances and how the keys LFU change over time, which
# is possible to inspect via the OBJECT FREQ command.
# Redis LFU驱逐（请参阅maxmemory设置）可以调优。然而，从默认设置开始是一个好主意，并且只在研究如何改进性能以及如何随着时间的推移改变键值之后才改变它们，这是可以通过OBJECT FREQ命令进行检查的。
#
# There are two tunable parameters in the Redis LFU implementation: the
# counter logarithm factor and the counter decay time. It is important to
# understand what the two parameters mean before changing them.
# 在Redis LFU实现中有两个可调参数：计数器对数因子和计数器衰减时间。
# 在改变它们之前，理解这两个参数意味着什么是很重要的。
#
# The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis
# uses a probabilistic increment with logarithmic behavior. Given the value
# of the old counter, when a key is accessed, the counter is incremented in
# this way:
# LFU计数器只有8比特/键，它的最大值是255，所以Redis使用对数行为的概率增量。
# 考虑到旧计数器的值，当一个键被访问时，计数器以这种方式递增：
#
# 1. A random number R between 0 and 1 is extracted.
#    在0和1之间的随机数字R被提取出来。
# 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).
#    一个概率P被计算为1/(old_value*lfu_log_factor+1).
# 3. The counter is incremented only if R < P.
#    计数器只有在R<p时才会增加。
#
# The default lfu-log-factor is 10. This is a table of how the frequency
# counter changes with a different number of accesses with different
# logarithmic factors:
# 默认的lfu-log-factor是10。
# 这是一个关于频率计数器如何随着不同数量的存取而变化的表格，不同的对数因子：
#
# +--------+------------+------------+------------+------------+------------+
# | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
# +--------+------------+------------+------------+------------+------------+
# | 0      | 104        | 255        | 255        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 1      | 18         | 49         | 255        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 10     | 10         | 18         | 142        | 255        | 255        |
# +--------+------------+------------+------------+------------+------------+
# | 100    | 8          | 11         | 49         | 143        | 255        |
# +--------+------------+------------+------------+------------+------------+
#
# NOTE: The above table was obtained by running the following commands:
# 注意：上面的表是通过运行以下命令获得的：
#
#   redis-benchmark -n 1000000 incr foo
#   redis-cli object freq foo
#
# NOTE 2: The counter initial value is 5 in order to give new objects a chance
# to accumulate hits.
# 注2：计数器的初始值为5，以便给新对象一个累积命中的机会。
#
# The counter decay time is the time, in minutes, that must elapse in order
# for the key counter to be divided by two (or decremented if it has a value
# less <= 10).
# 计数器衰减时间是指在几分钟内，为了使键计数器被2（如果它的值小于<=10），则必须间隔时间。
#
# The default value for the lfu-decay-time is 1. A Special value of 0 means to
# decay the counter every time it happens to be scanned.
# lfu-decay时段的默认值是1。0的特殊值意味着每次扫描时都要衰变计数器。
#
# lfu-log-factor 10
# lfu-decay-time 1
```

# 碎片
```
########################### ACTIVE DEFRAGMENTATION 活跃的碎片整理 #######################
#
# WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested
# even in production and manually tested by multiple engineers for some
# time.
# 警告这个特性是实验性的。
# 然而，即使是在生产过程中，也要进行压力测试，并在一段时间内由多个工程师进行手工测试。
#
# What is active defragmentation?
# 活跃的碎片整理是什么?
# -------------------------------
#
# Active (online) defragmentation allows a Redis server to compact the
# spaces left between small allocations and deallocations of data in memory,
# thus allowing to reclaim back memory.
# Active（联机）碎片整理允许一个Redis服务器压缩内存中小分配和数据的释放之间的空间，从而允许回收内存。
#
# Fragmentation is a natural process that happens with every allocator (but
# less so with Jemalloc, fortunately) and certain workloads. Normally a server
# restart is needed in order to lower the fragmentation, or at least to flush
# away all the data and create it again. However thanks to this feature
# implemented by Oran Agra for Redis 4.0 this process can happen at runtime
# in an "hot" way, while the server is running.
# 碎片化是一个自然的过程，它发生在每个分配器（幸运的是，幸运的是）和某些工作负载。
# 通常，需要重新启动服务器，以降低碎片，或者至少清除所有数据并再次创建它。
# 然而，由于奥兰阿格拉为Redis 4.0实现了这个特性，这个过程可以在运行时以“热”的方式发生，而服务器正在运行。
#
# Basically when the fragmentation is over a certain level (see the
# configuration options below) Redis will start to create new copies of the
# values in contiguous memory regions by exploiting certain specific Jemalloc
# features (in order to understand if an allocation is causing fragmentation
# and to allocate it in a better place), and at the same time, will release the
# old copies of the data. This process, repeated incrementally for all the keys
# will cause the fragmentation to drop back to normal values.
# 分裂时基本上超过一定水平(见下面的配置选项)复述,将开始创建新副本的值在连续的内存区域利用特定Jemalloc特性(为了理解如果一个分配导致分裂和分配在一个更好的地方),同时,将旧的数据的副本。
# 这个过程，对于所有的键都是递增的，将导致碎片化回到正常值。
#
# Important things to understand:
# 重要的事情要明白:
#
# 1. This feature is disabled by default, and only works if you compiled Redis
#    to use the copy of Jemalloc we ship with the source code of Redis.
#    This is the default with Linux builds.
#    这个特性在默认情况下是禁用的，并且只有在编译Redis时才会工作，以便使用我们附带的Redis的源代码。
#    这是Linux构建的默认值。
#
# 2. You never need to enable this feature if you don't have fragmentation
#    issues.
#    如果没有碎片问题，您永远不需要启用这个特性。
#
# 3. Once you experience fragmentation, you can enable this feature when
#    needed with the command "CONFIG SET activedefrag yes".
#    一旦您体验了碎片化，您就可以在需要的时候启用这个特性，命令“配置集activedefrag yes”。
#
# The configuration parameters are able to fine tune the behavior of the
# defragmentation process. If you are not sure about what they mean it is
# a good idea to leave the defaults untouched.
# 配置参数能够很好地调整碎片整理过程的行为。
# 如果您不确定它们的意思，那么保留默认值是一个好主意。


# Enabled active defragmentation
# 使活跃的碎片整理
# activedefrag yes


# Minimum amount of fragmentation waste to start active defrag
# 最少的碎片产生的碎片开始活动的defrag
# active-defrag-ignore-bytes 100mb


# Minimum percentage of fragmentation to start active defrag
# 开始活动的碎片化的最小百分比
# active-defrag-threshold-lower 10


# Maximum percentage of fragmentation at which we use maximum effort
# 最大的碎片百分比，我们使用最大的努力
# active-defrag-threshold-upper 100


# Minimal effort for defrag in CPU percentage
# 在CPU百分比上对defrag的最小努力
# active-defrag-cycle-min 25


# Maximal effort for defrag in CPU percentage
# 在CPU百分比上的最大努力
# active-defrag-cycle-max 75
```









