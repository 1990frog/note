# prototype

## 原型应用场景
1. 对象种类繁多，无法将他们整合到一个类的时候；
2. 难以根据类生成实例时；
3. 想解耦框架与生成的实例时。

如果想要让生成实例的框架不再依赖于具体的类，这时，不能指定类名来生成实例，而要事先“注册”一个“原型”实例，然后通过复制该实例来生成新的实例。

通过原型模式，绕过构造方法创建对象，利用内存直接拷贝对象，提高对象的创建性效率。在有大量的对象创建或者类初始化消耗多资源的场景下可以利用原型模式来优化。当然在实现的过程中，要注意浅拷贝与深拷贝的问题，防止写出 bug，文章主要介绍原型模式，就不详细说这个问题了，留给大家去扩展了解。

在原型模式结构中定义了一个抽象原型类，所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。

能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。

注意：java.lang.Cloneable 只是起到告诉程序可以调用clone方法的作用，它本身并没有定义任何方法。

在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为两种形式：**深克隆和浅克隆**。


