首先我是在学习SpringCloudAlibaba的时候，学习到了Ribbon配置的时候，需要自定义配置Ribbon的负载均衡规则，那么就需要写一个自定义的配置类了，所以用到了@Configuration注解。因为我是用的是SpringBoot项目作为主框架的，所以在使用@Configuration注解的时候就会与SpringBoot项目启动类上面的@SpringBootApplication注解产生父子上下文问题。接下来我们解析一下：

首先我们可以查看一下@Configuration注解，发现是一个组合注解，其中里面就包含了@Component注解，也就是说@Configuration注解也是一种特殊的Component。

接下来我们再看一下@SpringBootApplication注解，他也是一个组合注解，其中里面也包含了一个@ComponentScan注解，解释一下@ComponentScan注解的作用是用来扫描Component的，也就是说@Component,@Controller,@Service,@Repository等这些Component注解都会被扫描到，包括上面提到的@Configuration注解也会被扫描到。默认扫描的位置是当前启动类所在的包以及启动类包下面的所有Component。

通过上面的描述，Ribbon的配置类一定不能让@SpringBootApplication注解扫描到。这是为什么呢？？？这就是因为Spring的上下文，是一个树状的上下文。在我们的应用里@SpringBootApplication注解所扫描的上下文叫主上下文，而Ribbon也会有一个上下文，是一个子上下文。那么如果父子上下文所扫描的包重叠，就会出现各种各样奇葩的问题。。。

下面说一下，Spring父子上下文扫描重叠的问题。我们可以通过以前使用的xml配置文件形式了解一下。我是使用Spring+SpringMVC的项目理解的。

---

spring总的上下文容器有父子之分。父容器和子容器。父容器对子容器可见，子容器对父容器不可见。

父子容器的使用场景
父子容器的主要用途是上下文隔离。考虑以下一种场景。

project-service.jar为服务层模块。包含一些数据库service方法。其对应的spring配置文件为project-service.xml。
project-api为api服务器代码。它依赖于project-service.jar。其对应的配置文件为project-api.xml。
project-api需要对project-service里的某些方法进行decorate，进行装饰，比如给CustomerService进行装饰。装饰后的类为CachedCustomerService。于是，现在project-api里面包含两个CustomerService，一个是来自project-service的CustomerService，另一个是CachedCustomerService。这个时候，如果project-api工程所有的配置文件都通过一个上下文进行加载，势必出现问题(通常的做法是用import标签全部给import进来)。因为，project里的PayService里通过@Resource标准注入了CustomerService，类似如下

---


spring上下文重叠
引导上下文
父子上下文
引导上下文是ApplicationContext的上下文
ApplicationContext与Ribbon也是父子上下文
ApplicationContext与Feign也是父子上下文