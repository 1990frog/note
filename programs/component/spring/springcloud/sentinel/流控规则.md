[TOC]

# 流量控制规则（FLowRule）
|      Field      |                            说明                            |          默认值          |
| -------------- | --------------------------------------------------------- | ----------------------- |
| resource        | 资源名，资源名是限流规则的作用对象	                             |                         |
| count           | 限流阈值	                                                 |                         |
| grade           | 限流阈值类型，QPS模式（1）或并发线程数模式（0）	                 | QPS 模式                 |
| limitApp        | 流控针对的调用来源	                                         | default，代表不区分调用来源 |
| strategy        | 调用关系限流策略：直接、链路、关联	                             | 根据资源本身（直接）        |
| controlBehavior | 流控效果（直接拒绝 / 排队等待 / 慢启动模式），不支持按调用关系限流	 | 直接拒绝                 |
| clusterMode     | 是否集群限流	                                             | 否                      |

通过代码定义流量控制规则
理解上面规则的定义之后，我们可以通过调用 FlowRuleManager.loadRules() 方法来用硬编码的方式定义流量控制规则，比如：
```java
private void initFlowQpsRule() {
    List<FlowRule> rules = new ArrayList<>();
    FlowRule rule = new FlowRule(resourceName);
    // set limit qps to 20
    rule.setCount(20);
    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
    rule.setLimitApp("default");
    rules.add(rule);
    FlowRuleManager.loadRules(rules);
}
```

# 流控规则（流量控制）对应的类FlowRule
流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。

![](https://gitee.com/caijingquan/imagebed/raw/master/1602319244_20200314003632736_2074418010.png)

# 关键字：阈值类型
## 线程数流量控制
并发线程数限流用于保护业务线程数不被耗尽。例如，当应用所依赖的下游应用由于某种原因导致服务不稳定、响应延迟增加，对于调用者来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。为应对太多线程占用的情况，业内有使用隔离的方案，比如通过不同业务逻辑使用不同线程池来隔离业务自身之间的资源争抢（线程池隔离）。这种隔离方案虽然隔离性比较好，但是代价就是线程数目太多，线程上下文切换的 overhead 比较大，特别是对低延时的调用有比较大的影响。

Sentinel并发线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程数目，如果超出阈值，新的请求会被立即拒绝，效果类似于信号量隔离。

并发限流不能使用匀速排队策略
## QPS流量控制
当QPS超过某个阈值的时候，则采取措施进行流量控制。流量控制的效果包括以下几种：快速失败、Warm Up、匀速排队。
注意：若使用除了直接拒绝之外的流量控制效果，则调用关系限流策略（strategy）会被忽略。

# 关键字：流控模式（基于调用关系的流量控制）
+ 直接（自我）
+ 关联（a与b并发，一方让步）
+ 链路（a调用b）
## 直接模式
限定资源本身，如果本资源达到了【阈值】，就可以触发对应的【流控效果】
## 关联模式
当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。

资源名：操作1
关联资源：操作2
到操作2达到阈值就限流操作1这个资源

当【关联资源】达到【阈值】就流控【资源名】
## 链路模式
资源A分别被资源B与资源C调用，假设B是充值会员那就不给B做流控，C是白嫖的达到阈值就控他

# 关键字：流控效果
## 快速失败
被kill掉，直接抛异常

当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出`FlowException`。
这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。
类似线程池已经达到最大线程数，而且有容量限制的`queue`满了，直接就开始拒绝工作了

相关代码：`com.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController`
## 排队等待（流量整形，削峰填谷，漏桶算法）
匀速排队方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是`漏桶算法`

如果使用这种模式，那么阈值类型必须设成qps，不能使用线程，否则无效

这种方式主要用于处理间隔性突发的流量，例如`消息队列`（消息队列是异步的，这个不是）。

想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。

漏桶算法
桶算法就像我们平常使用的漏斗、不管我们倒入液体的速度有多快，漏斗都是从下面的小口匀速流出。漏桶算法跟漏斗类似，调用方作为“水滴”的消费者、我们限流方作为“水滴”的提供者、无论调用方调用频率多么不稳定、我们服务提供者只允许它按照固定的速率获取数据。

![](https://gitee.com/caijingquan/imagebed/raw/master/1602319245_20200314003713920_388937887.png)
源码：`com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController`

### 例子
适用于应对突发流量的场景
设置单机阈值10，每秒只运行10次请求，再设置超时时间500，超过500s就丢弃这次请求

### 拓展
redis与guava也可以支持单机漏桶

## Warm Up（预热，联想一下redis内存穿透，一开始不让太多连接打到数据库）
即预热/冷启动方式。将达到峰值的时间拉长

当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。

通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮
根据codeFactor（默认3）的值，从`阈值/codeFactor`初始值，经过预热时长，才达到设置的qps阈值

源码：`com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController`
`看看Google guava SmoothRateLimiter.java`

![](https://gitee.com/caijingquan/imagebed/raw/master/1602319245_20200314003657072_1276072412.png)

### 例子
假设单机阈值设置100，预热时长设置10s，那么就会用100/3作为最初的阈值，达到10s之后才会设置100为阈值
超时时间存在的目的是为了避免OOM

# 集群流控
为什么要使用集群流控呢？假设我们希望给某个用户限制调用某个 API 的总 QPS 为 50，但机器数可能很多（比如有 100 台）。这时候我们很自然地就想到，找一个 server 来专门来统计总的调用量，其它的实例都与这台 server 通信来判断是否可以调用。这就是最基础的集群流控的方式。

另外集群流控还可以解决流量不均匀导致总体限流效果不佳的问题。假设集群中有 10 台机器，我们给每台机器设置单机限流阈值为 10 QPS，理想情况下整个集群的限流阈值就为 100 QPS。不过实际情况下流量到每台机器可能会不均匀，会导致总量没有到的情况下某些机器就开始限流。因此仅靠单机维度去限制的话会无法精确地限制总体流量。而集群流控可以精确地控制整个集群的调用总量，结合单机限流兜底，可以更好地发挥流量控制的效果。

集群流控中共有两种身份：
+ Token Client：集群流控客户端，用于向所属 Token Server 通信请求 token。集群限流服务端会返回给客户端结果，决定是否限流。
+ Token Server：即集群流控服务端，处理来自 Token Client 的请求，根据配置的集群规则判断是否应该发放 token（是否允许通过）。

