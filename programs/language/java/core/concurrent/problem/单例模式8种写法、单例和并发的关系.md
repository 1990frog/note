[TOC]

# 单例模式的作用
为什么需要单例：节省内存和计算、保证结果正确、方便管理

# 单例模式适用场景
1.无状态的工具类：比如日志工具类，不管是在哪里使用，我们需要的只是它帮我们记录日志信息，除此之外，并不需要在它的实例对象上存储任何状态，这时候我们就只需要一个实例对象即可。
2.全局信息类：比如我们在一个类上记录网站的访问次数，我们不希望有的访问被记录在对象A上，有的却记录在对象B上，这时候我们就让这个类成为单例。

# 单例模式的8种写法
1.饿汉式（静态常量）【可用】
2.饿汉式（静态代码块）【可用】
3.懒汉式（线程不安全）【不可用】
4.懒汉式（线程安全，同步方法）【不推荐用】
5.懒汉式（线程不安全，同步代码块）【不可用】
6.双重检查【推荐用】
7.静态内部类【推荐用】
8.枚举【推荐用】生产实践中最佳写法


```java
synchronized static method

synchronized (Singleton5.class) {//类同步
                instance = new Singleton5();
            }
```

新建对象不是原子操作：

额外解释
在这里的双重检查想要防止的，是这种特殊情况：
“在第一个线程退出synchronized之前，里面的操作执行了一部分，比如执行了new却还没执行构造函数，然后第一个线程被切换走了，这个时候第二个线程刚刚到第一重检查，所以看到的对象就是非空，就跳过了整个synchronized代码块，获取到了这个单例对象，但是使用其中的属性的时候却不是想要的值。”

![20191021232443594_581383191](https://gitee.com/caijingquan/imagebed/raw/master/1602317706_20191022144326231_43917173.png)

# 双重检查

优点：线程安全、延迟加载、效率较高
为什么要double-check
1.线程安全
2.单check行不行：不行（线程不安全）
3.性能问题：synchronized method
为什么要用volatile
1.新建对象实际上有3个步骤
2.重排序会带来NPE
3.防止重排序

# 不同写法对比

饿汉：简单、但是没有lazy loading
懒汉：有线程安全问题
静态内部类：可用
<font color="red">双重检查：面试用</font>
<font color="red">枚举：最好</font>

# 用那种单例的实现方案最好？

Joshua Bloch大神在《Effective Java》中明确表达过的观点：“使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经称为实现Singletond的最佳方法。”

写法最简单

线程安全有保障（反编译之后，可以看到，枚举会变成一个final class继承枚举的一个父类，并且在这个父类中他的各个实例都是通过static来定义的，所以枚举的本质就是一个静态的对象）

避免反序列化破坏单例

# 各个写法的适用场合
最好的方法是利用枚举，因为还可以防止反序列化重新创建新的对象；
非线程同步的方法不能使用；
如果程序一开始要加载的资源太多，那么就应该用懒加载；
饿汉式如果是对象的创建需要配置文件就不适用。
懒加载虽然好，但是静态内部类这种方式会引入编程复杂性。

# 单例模式面试常见问题

饿汉式的缺点？
懒汉式的缺点？
为什么要用double-check？不用就不安全吗？
为什么双重检查模式要用volatile？