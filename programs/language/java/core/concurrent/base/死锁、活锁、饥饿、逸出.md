[TOC]

# 例子
前提：druid maxsize=1
第一步：required事务占用一个线程
第二步：再调用required_new需要获取一个新的资源（资源0），这一步一直获取不到线程将整个流程都阻塞了，所以死锁了


# 死锁的4个必要条件（缺一不可）
+ 互斥（mutual exclusion）：资源只能同时分配给一个行程，无法多个行程共享
+ 持有和等待（hold and wait）：一个进程可以在等待时持有系统资源，例如：第一个线程请求第二把锁但是持有第一把锁
+ 禁止剥夺（no preemption）：不能有外界干扰、外界剥夺
+ 循环等待（circular waiting）：构成环路

死锁只有在四个条件同时满足时发生，预防死锁必须至少破坏其中一项。
破解其中一个条件，就不会发生死锁

# 什么是死锁
互不想让：当两个（或更多）线程（或进程）互相持有对方所需要的资源，又不主动释放，导致所有人都无法相继前进，导致程序陷入无尽的阻塞，这就是死锁。如果多个线程之间的依赖关系是环形，存在环路的锁的依赖关系，那么也可能会发生死锁。
![嵌套式死锁原理](https://gitee.com/caijingquan/imagebed/raw/master/1602317524_20200117152053218_619568720.png)
# 死锁的影响
死锁的影响在不同系统中是不一样的，这取决于系统对死锁的处理能力
数据库中：检查并放弃事务（类似第一个事务放弃，后面执行之后任务再接着执行第一个事物）
JVM中：无法自动处理（但可以检测）

几率不高但危害大
不一定发生，但是遵守“墨菲定律”，一旦发生，多是高并发场景，影响用户多。整个系统崩溃、子系统崩溃、性能降低，压力测试无法找出所有潜在的死锁
# 如何定位死锁
+ jstack
+ ThreadMXBean

```shell
$ jps
$ jstack <pid>
```

# 实际工程中如何避免死锁
1. 设置超时时间（Lock的tryLock（long timeout,TimeUnit unit））
2. 多使用并发类而不是自己设计锁
3. 尽量降低锁的使用粒度：用不同的锁而不是一个锁
4. 如果能使用同步代码块，就不使用同步方法：自己指定锁对象（缩小范围、可控锁对象，同步方法的锁不是我们控制的）
5. 给线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践
6. 避免锁的嵌套：MustDeadLock类
7. 分配资源前先看能不能收回来：银行家算法


---

# 活锁与死锁的区别
活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。

死锁：每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉
活锁：在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，再等五分钟，又同时拿起这些餐叉
（优化策略，等待时间不同）

# 什么是活锁
虽然线程并没有阻塞，也始终在运行（所以叫做“活”锁，线程是“活”的），但是程序却得不得进展，因为线程始终重复做同样的事。

工程中的活锁实例：消息队列
策略：消息如果处理失败，就放在队列开头重试
由于依赖服务除了问题，处理该消息一直失败
没阻塞，但程序无法继续

如果处理失败的消息放到队列尾部就不会发生死锁，最好加上重试限制，如果过了限制（重试n次）我们就认为它短时间无法恢复了，这个时候我们把这个数据放到数据库中，触发处理机制

饥饿
当线程需要某些资源（例如CPU）,但是却始终得不得
线程的优先级设置得过于低，或者有某线程持有锁同时又无限循环而不释放锁，或者某程序始终占用某文件的写锁。

饥饿可能会导致响应性差：
比如，我们的浏览器有一个线程负责处理前台响应（打开收藏夹等动作），另外的后台线程负责下载图片和文件、计算渲染等。在这种情况下，如果后台线程把CPU资源都占用了，那么前台线程将无法得到很好地执行，这会导致用户的体验很差。

线程优先级
10个级别，默认5
程序设计不应依赖于优先级，不同的操作系统不一样
windows有7个优先级
linux会忽略优先级

优先级会被操作系统改变别？
