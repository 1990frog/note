[TOC]

# 什么场景中会用到多线程？

什么时候需要新开线程？
通常在需要进行耗时任务的时候，例如执行磁盘IO读写

为了同时做多件不同的事
开网页同时听音乐
后台线程：比如执行定时任务quartz

为了提高工作效率、处理能力
tomcat
多线程后台并行下载文件
NIO和AIO

需要同时有很大并发量的时候
压测

# 多线程的局限
上下文切换带来的消耗
异构化任务（任务结构不一样）很难高效并行


# 线程与进程

![](https://gitee.com/caijingquan/imagebed/raw/master/1602317579_20191023214303817_775910896.png)

## Oracle文档的官方定义
process：使用fork(2)系统调用创建的unix环境（例如文件描述符，用户id等），它被设置位运行程序。
thread：在进程上下文中执行的一系列指令。

## 悟空的解释
进程的英文是process，指的是程序的一次执行。在用户下达运行程序的命令后，就会产生进程。进程是对代码的实例化。
活动监视器展示的就是进程
ps aux
![](https://gitee.com/caijingquan/imagebed/raw/master/1602317580_20191023215140359_572581429.png)

总结：进程是程序（这里可以理解为我们写的代码）的真正运行实例，是资源分配的基本单位。

类比：
进程是一个房子，而线程是住户，房子不是做事的，做事的是房子中的人，所以进程是线程的容器。

# 线程与进程的不同
## 起源不同
先用进程后有线程，后来由于处理器的速度要比外设（输入设备、硬盘）快，所以为了提高CPU的利用率，才诞生了线程。目的就是提高程序的执行效率
## 概念不同
进程是拥有独立功能的一个程序运行起来的一个活动，是一个实例；它也是我们系统分配资源和调度的独立的单位。而线程是CPU的独立调度单位。
## 内存共享方式不同
对应进程而言，不同的进程之间它们都会被操作系统分配内存，但是不同进程的内存通常是不共享的，比如说我们的浏览器无法访问播放音乐的软件的内存。它们要是想要通信，除非使用高级技巧，叫做进程间通信IPC。而线程与线程之间，它们共享就容易多了，因为它们都服务于同一个进程。它们可以直接访问一定量的共享内存，不需要任何额外的处理。
## 拥有资源不同
线程本身是进程的一部分，所以它拥有的资源一定是少于进程的
## 线程共享的内容包括
1.进程的代码段
2.进程的共有数据（利用这些共享的数据，线程很容易的实现相互的通讯）
3.进程打开的文件描述符
4.信号的处理器
5.进程的当前目录
6.进程用户ID与进程组ID
## 线程独有的内容包括（线程不共享的）：
1.线程ID
2.寄存器组的值
3.线程的堆栈
4.错误返回码
5.线程的信号屏蔽码
## 数量不同
## 开销不同
1.线程的创建、终止时间比进程短
2.同一进程内的线程切换时间比进程切换短
3.同一进程的各个线程间共享内存和文件资源，可以不通过内核进行通信

# 相似点
生命周期

# JAVA语言与多线程的关系
java设计支持就支持多线程
java语言在服务端开发语言中的地位
一对一映射到操作系统的内核线程（有些语言的线程是虚拟线程，它不会在操作系统中对应的去创建线程，在java中我们创建100个线程就会实实在在的看到多出来100个线程）

## JVM自动启动线程debugger观察：
Signal Dispatcher：把操作系统发来的信号分发给适当的处理程序
Finalizer：负责对象的finalized()方法【随着java语言的发展finalized方法不在推荐使用】
Reference Handler：和GC、引用相关的线程
main：主线程、用户程序的入口

## 什么是多线程？
多线程的概念：如果一个程序允许两个或以上的线程，那么它就是多线程程序。多线程是指在单个进程中运行的多个线程。

## 比喻
客厅（进程）
厕所（互斥锁）
独立房间（每一个线程用有的独立资源）
花园浇水（合作）

大火锅一人吃（单进程单线程）
大火锅多人吃（单进程多线程）
单独吃小火锅（多进程）

## 为什么需要多线程？
最主要的目的就是提高CPU利用率
1.避免无效等待（IO的时候可以做别的事）
2.提高用户体验：避免卡顿、缩短等待时间
1）并行处理，提高性能，通常是服务领域（例如Tomcat），用多个线程去接收进来的HTTP请求，而不是排队等待单一的线程处理。
2）在Android开发中，主线程的重要任务之一是绘制屏幕界面，该线程中不允许进行IO操作或网络请求，目的就是避免卡顿，影响用户的交互。
便于编程建模
计算机性能定律：摩尔定律失效，阿姆达尔定律登上舞台
处理器越多，程序执行越快，但有上限，取决于程序中串行部分的比例，并行的比例越高，多处理器的效果越明显。

![](https://gitee.com/caijingquan/imagebed/raw/master/1602317581_20191024210103924_1713681536.png)

## 什么情景中会用到多线程？
为了同时做多件不同的事：
1）开网页同时听音乐
2）后台定时任务
为了提高工作效率、处理能力：
1）tomcat
2）并行下载
3）NIO
需要同时有很大并发量的时候：
1）压测

## 多线程的局限
性能问题：上下文切换带来的消耗
异构化任务（任务结构不一样）很难高效并行
带来线程安全的问题：包括数据安全问题（例如i++总数不一致）以及线程带来的活跃性问题（线程饥饿、死锁）。

# 串行、并行、并发
并发和并行、进程核线程、多进程和多线程的区别：（这里的时间和时刻上的概念同物理上的一样）
并发：在一段时间内多个任务同时执行，或者说是在一段很短的时间内可以执行多条程序指令，微观上看起来好像是可以同时运行多个进程，单核处理器就可以做到。
并行：在同一时刻多个任务同时执行，或者说是在同一时刻可以执行多条程序指令，多核处理器才可以做到。
进程：进程是程序的一次执行过程，是系统运行程序的基本单位，打开 Windows 的任务管理器就可以看到很多进程。
线程：线程与进程相似，但线程是一个比进程更小的执行单位，一个进程在其执行的过程中可能产生多个线程。
多进程：每个进程都拥有自己独立的资源，多个进程可在单核处理器上并发执行，在多核处理器上并行执行。
多线程：一个进程可由多个线程组成，多个线程共享进程内资源，多个线程可在单核处理器上并发执行，在多核处理器并行执行。
在多核处理器上，并发和并行同时存在，处理器上的每个核同一时刻同时执行多个任务，每个核在很短的时间段内又同时执行多个任务，对多任务粗略划分是多个进程，对进程划分可能又是多个线程。同一时刻，处理器的每个核只能运行一个进程中的一个线程中的一条指令（Intel 的超线程技术，如双核四线程，四核八线程，处理器的线程（硬件上）和进程中的线程（软件上）不是一个概念，这个所谓的超线程技术也并不能达到真正的多核效果，只是提高了处理器的吞吐量核利用率）。

线程比进程更加的轻量级，进程和线程都是提高程序并发性和系统性能的手段，但并不是说进程越多或线程越多，性能越高，还要结合硬件设备和操作系统来看。



![](https://gitee.com/caijingquan/imagebed/raw/master/1602317582_20191024214244275_1140261967.png)

## 并发、并行
![](https://gitee.com/caijingquan/imagebed/raw/master/1602317583_20191024214429346_954701571.png)

并发可能通过单核处理器实现
并行一定要通过多核处理器实现

![](https://gitee.com/caijingquan/imagebed/raw/master/1602317584_20191024214607298_1161174311.png)

并行的概念：
真正的“同时”运行——在同一时刻，有多个任务同时执行
例如，在多核处理器上，有两个线程同时执行同一段代码。
可见，单核处理器是无法实现并行的，因为单核处理器无法在同一时刻执行多个任务。

并发的两种概念：
1.形容多个任务的执行状态：
两个或多个任务在重叠的时间段内启动、运行和完成
并行（两个线程同时执行）一定是并发
并发不一定是并行（并发包含并行）
2.对“并发性”的简称
不同的部分可以无序或同时执行，且不影响最终的执行结果
在不同核心数的计算机上不同表现
此时，并行和并发的概念并不在同一维度上

## 串并行和并发的实际例子
打游戏时，女朋友来电话
并发：大脑在聊天与打游戏之间快速切换
串行：关闭游戏与女朋友聊天，打完电话之后再重新玩游戏

# 是什么让并发和并行成为可能？
CPU升级
操作系统升级：有权利中断任务，控制执行顺序（抢占性）
编程语言升级

# 高并发
## 什么是高并发
同时有很多个请求发送给服务器系统，因此服务器就会并行处理
pv值

## 高并发和多线程的联系和不同
多线程：解决方案
高并发：状态
多线程编程是我们为了应对高并发这种状态的一种非常重要的解决方案
高并发并不意味着是多线程：Redis
Redis底层是单线程处理的（高并发并不意味着是多线程）

## 高并发有哪些指标
QPS（Queries Per Second）每秒查询数（每秒请求数）
带宽
PV（Page View）综合浏览量（一天之内的页面点击量）
UV（Unique Visitor）用户数
IP和UV的区别
并发连接数（The number of concurrent connections）
服务器平均请求等待时间（Time per request:across all concurrent requests）

# 同步与异步、阻塞与非阻塞
同步与异步：被调用者是否主动告诉调用者结果
阻塞与非阻塞：我是调用者，我调用一个东西之后，结果返回前，是否还能做别的事

![](https://gitee.com/caijingquan/imagebed/raw/master/1602317584_20191024223121502_1227726567.png)

![](https://gitee.com/caijingquan/imagebed/raw/master/1602317585_20191024223214034_83594026.png)

![](https://gitee.com/caijingquan/imagebed/raw/master/1602317586_20191024223241173_962481441.png)

![](https://gitee.com/caijingquan/imagebed/raw/master/1602317586_20191024223313421_1410744882.png)

同步：同步异步这里指的是被调用者（也就是服务器）的行为，而不是请求方的行为。在没有得到结果之前，服务端就不返回任何结果。

异步：调用在发出之后，服务端会立刻返回，告诉调用方“我收到你的请求了，我会处理的”

阻塞与非阻塞是站在请求方

水壶例子
同步阻塞：按下烧水开关之后什么都不做就开始等，水壶不会主动告诉我们结果，要我们去检查
同步非阻塞：还是用原来的水壶，它还是不会提醒我们。我烧水之后就去干别的事情。
异步阻塞：按下烧水按钮之后什么也不做，等水壶通知我们
异步非阻塞：按下开关之后去做别的事情，等水壶通知我们

同步异步与阻塞非阻塞没有关系
