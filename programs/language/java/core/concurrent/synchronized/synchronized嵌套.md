[TOC]

# 情况1：两个线程同时访问一个对象的同步方法（同一把锁）
```java

```
# 情况2：两个线程访问的是两个对象的同步方法（两把不同的锁）
```java

```
# 情况3：两个线程访问的是synchronized的静态方法（同一把锁：类锁）
```java

```
# 情况4：同时访问同步方法与非同步方法（非同步方法不受到影响）
```java

```
# 情况5：访问同一个对象的不同的普通同步方法（同一把锁，串行）
```java

```
# 情况6：同时访问静态synchronized和非静态synchronized方法（两把锁，一把对象锁、一把类锁）
```java

```
# 情况7：方法抛出异常后，会释放锁（Lock不会释放锁，synchronized会）
```java

```

# 7种情况总结：3点核心思想
1. 一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应1、5种情况）；
2. 每个实例都对应有自己的一把锁，不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象共用同一把类锁（对象第2、3、4、6种情况）；
3. 无论方法是正常执行完毕或者方法抛出异常，都会释放锁（对应第7种）

# 在Synchronized方法中调用非Synchronized方法，是线程安全的吗？
不是，非Synchronized方法，可以被多个线程同时访问，所以不是线程安全的（除非入口是在Synchronized方法中）