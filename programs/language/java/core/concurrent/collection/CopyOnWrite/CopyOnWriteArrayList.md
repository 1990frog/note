[TOC]

# 原理
CopyOnWriteArrayList，是一个写入时复制的容器，它是如何工作的呢？
简单来说，就是平时查询的时候，都不需要加锁，随便访问，只有在写入/删除的时候，才会从原来的数据复制一个副本出来，然后修改这个副本，最后把原数据替换成当前的副本。
修改操作的同时，读操作不会被阻塞，而是继续读取旧的数据。这点要跟读写锁区分一下。
CopyOnWriteArrayList可以在迭代中修改。

# 概览
+ 代替Vector和SynchronizedList，就和ConcurrentHashMap代替SynchronizedMap的原因一样
+ Vector和SynchronizedList的锁的粒度太大，并发效率相对比较低，并且迭代时无法编辑

# 适用场景
+ 读操作可以尽可能地快，而写操作即使慢一些也没有太大关系
+ 读多写少：黑名单，每日更新；监听器：迭代操作远多余修改操作

# 读写规则
+ 回顾读写锁：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥）
+ 读写锁规则的升级：读取是完全不用加锁的，并且更厉害的是写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待

# 缺点
+ 数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的数据，马上能读到，请不要使用CopyOnWrite容器
+ 内存占用问题：因为CopyOnWrite的写是复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存

