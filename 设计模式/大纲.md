<!-- TOC -->

- [什么是设计模式](#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)
- [本质](#%E6%9C%AC%E8%B4%A8)
- [表述格式](#%E8%A1%A8%E8%BF%B0%E6%A0%BC%E5%BC%8F)
- [设计原则](#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99)
- [创建型模式](#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F)
- [结构型模式](#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F)
- [行为型模式](#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F)
- [GOF](#gof)

<!-- /TOC -->

[wiki](https://zh.wikipedia.org/zh-cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA))

# 什么是设计模式
在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。

设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。

并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。

# 本质
设计模式的本质是抽象、解耦，用抽象来隔离变化。将复杂的事务按照六大设计原则，分解成一个个单一职责的个体，换而言之，是个体的高内聚和简单化。然后再组合到一起完成职能。合理使用设计模式可以使程序设计更加标准化。代码可重用性更高、灵活性好、可维护性强。

# 表述格式
+ 模式名：每一个模式都有自己的名字，模式的名字使得我们可以讨论我们的设计。
+ 问题：在面向对象的系统设计过程中反复出现的特定场合，它导致我们采用某个模式。
+ 解决方案：上述问题的解决方案，其内容给出了设计的各个组成部分，它们之间的关系、职责划分和协作方式。
+ 别名：一个模式可以有超过一个以上的名称。这些名称应该要在这一节注明。
+ 动机：在哪种情况使用该模式，是本节提供的方案（包括问题与来龙去脉）的责任。
+ 适用性：模式适用于哪些情况、模式的背景等等。
+ 结构：这部分常用类图与交互图阐述此模式。
+ 参与者：这部分提供一份本模式用到的类与对象清单，与它们在设计下扮演的角色。
+ 合作：描述在此模式下，类与对象间的交互。
+ 影响：采用该模式对软件系统其他部分的影响，比如对系统的扩充性、可移植性的影响。影响也包括负面的影响。这部分应描述使用本模式后的结果、副作用、与权衡(trade-off)。
+ 实现：这部分应描述实现该模式、该模式的部分方案、实现该模式的可能技术、或者建议实现模式的方法。
+ 示例：简略描绘出如何以编程语言来使用模式。
+ 已知应用：业界已知的实现示例。
+ 相关模式：这部分包括其他相关模式，以及与其他类似模式的不同。

# 设计原则
+ 开闭原则：对扩展开放，对修改关闭。
+ 里氏代换原则：任何基类可以出现的地方，子类一定可以出现。
+ 依赖倒置原则：针对接口编程，依赖抽象而不依赖具体。
+ 接口隔离原则：拆分大接口，使用多个隔离接口，降低类间耦合。
+ 迪米特法则：最少知道原则，实体间尽量少的发生相互作用。
+ 合成复用原则：尽量使用合成/聚合的方式，而不是继承。

# 创建型模式
+ [工厂模式](Factory.md)：创建同一接口的封装对象。
+ [单例模式](Singleton.md)：类只实例化一次。
+ [建造者模式](Builder.md)：用来创建复合对象，隐藏实现细节。
+ [原型模式](Prototype.md)：对象复制，减少对象创建。

# 结构型模式
+ [适配器模式Adapter](Adapter.md)：类、对象、接口适配器，将接口转换成另一个目标接口，消除不兼容问题。
+ [装饰器模式](Decorator.md)：给对象添加动态的添加功能。
+ [代理模式](Proxy.md)：用另一个类来代替原对象执行操作。
+ 外观模式：将多个类放到一个类中，降低类间耦合度。
+ 桥接模式：事物内部抽象类具体实现不同，相同方法产生不同结果，分离抽象和实体。
+ 组合模式：部分整体的结构，类似树形结构。
+ [享元模式](Flyweight.md)：对象共享池。

# 行为型模式
+ 策略模式：相同接口，不同实现类，同一方法结果不同，实现策略不同。
+ 模板方法模式：父类执行子类功能，但由子类实现。
+ 观察者模式：子类的动作，观察者能即使发现做出反应。
+ 迭代子模式：顺序遍历对象。
+ [责任链模式](Chain.md)：每个类持有下个对象的引用，形成链条。
+ 命令模式：调用者通过中间类让接受者执行指令。
+ 备忘录模式：备份模式，记录自生参数，需要的时候恢复。
+ 状态模式：改变状态参数，相同方法不同实现。
+ 访问者模式：通过接收访问者类，让访问者类改变主类的行为。
+ 中介者模式：通过中介者类管理另外几个类的关系。
+ 解释器模式：解释一种模式，比如正则表达式的解释器。

# GOF
1. Adapter：将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。
2. Bridge：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
3. Builder：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
4. Chain：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
5. Command：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
6. 