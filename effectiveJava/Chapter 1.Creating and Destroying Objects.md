<!-- TOC -->

- [用静态工厂方法代替构造器](#%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8)
    - [优点](#%E4%BC%98%E7%82%B9)
- [遇到多个构造器参数时要考虑使用构建器](#%E9%81%87%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E6%97%B6%E8%A6%81%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E6%9E%84%E5%BB%BA%E5%99%A8)
- [用私有构造器或者枚举类型强化Singleton属性](#%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E8%80%85%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%8C%96singleton%E5%B1%9E%E6%80%A7)
- [通过私有构造器强化不可实例化的能力](#%E9%80%9A%E8%BF%87%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%BA%E5%8C%96%E4%B8%8D%E5%8F%AF%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E8%83%BD%E5%8A%9B)
- [优先考虑依赖注入来引用资源](#%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%9D%A5%E5%BC%95%E7%94%A8%E8%B5%84%E6%BA%90)
- [避免创建不必要的对象](#%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1)
- [消除过期的对象引用](#%E6%B6%88%E9%99%A4%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8)
- [避免使用终结方法和清除方法](#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95%E5%92%8C%E6%B8%85%E9%99%A4%E6%96%B9%E6%B3%95)
- [try-with-resources优先于try-finally](#try-with-resources%E4%BC%98%E5%85%88%E4%BA%8Etry-finally)

<!-- /TOC -->
# 用静态工厂方法代替构造器
## 优点
1. 静态方法有名称，可以准确的描述返回的类型，产生的客户端代码更易于阅读
2. 不必每次调用都创建一个新对象
3. 可以返回原返回的类型的任何子类型的对象（适用于基于接口的框架）
4. 



# 遇到多个构造器参数时要考虑使用构建器
使用重叠构造器，当有许多参数的时候，客户端代码会很难编写，并且难以阅读
使用javabean模式，无法保证类的不可变性
Builder模式，可以保证类似重叠构造器那样的安全性，也能保证javabean类似的可读性
Builder模式模拟了具名的可选参数

# 用私有构造器或者枚举类型强化Singleton属性

# 通过私有构造器强化不可实例化的能力

# 优先考虑依赖注入来引用资源

# 避免创建不必要的对象

# 消除过期的对象引用

# 避免使用终结方法和清除方法

# try-with-resources优先于try-finally